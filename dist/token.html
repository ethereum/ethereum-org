<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>Create a cryptocurrency contract in Ethereum</title><meta name="description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><meta name="twitter:card" value="summary"><meta property="og:title" content="Create a cryptocurrency contract in Ethereum"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ethereum.org/token"><meta property="og:image" content="https://ethereum.org/images/social-token.jpg"><meta property="og:image:width" content="500"><meta property="og:image:height" content="500"><meta property="og:description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,600,900,400italic" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/frontier.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css"></head><body><div data-when="enter" data-from="1" data-to="0.8" data-opacity="0" data-translatey="-20" class="breadcrumb animateme"><a href="/" class="index">Ethereum </a><strong>Â»  Create your own crypto-currency</strong><a href="/crowdsale" class="next">Next</a></div><div id="tutorial-start" class="main-tutorial token-tutorial inner-header inner-page even"><div class="container"><div class="row"><div class="col-md-6 tutorial scrollme"><figure class="coin scrollme"><div data-when="enter" data-to="1" data-from="0.5" data-opacity="0" data-translatey="0" class="coin-connection animateme"></div><div data-when="enter" data-to="0.9" data-from="0.8" data-opacity="0" data-translatey="-50" data-translatex="-200" class="coin-send animateme"></div><div data-when="enter" data-to="0.5" data-from="0" data-opacity="0" data-translatey="-100" data-scale="1.5" data-rotate="45" class="coin-users animateme"></div><div data-when="enter" data-to="0.6" data-from="0.4" data-opacity="0" data-scale="0.5" data-translatey="-10" class="coin-coins animateme"></div></figure></div><div class="col-md-6 tutorial scrollme">         <div class="header-title"><h3 data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear" class="animateme">Create your own  </h3><h2 data-when="exit" data-from="0" data-to="1" data-translatey="400" data-easing="linear" class="animateme">crypto-currency</h2><h3 data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear" class="animateme">with Ethereum</h3></div></div></div></div></div><div class="main-tutorial inner-tutorial"><div class="container"><div class="row scrollme">               <ul id="tableOfContents" data-when="enter" data-from="0.4" data-to="0.2" data-translatex="-100" data-opacity="0" data-easing="linear" class="toc animateme"></ul><div class="col-md-12"><h3>The Coin</h3>

<p>We are going to create a digital token. Tokens in the ethereum ecosystem can represent any fungible tradable good: coins, loyalty points, gold certificates, IOUs, in game items, etc. Since all tokens implement some basic features in a standard way, this also means that your token will be instantly compatible with the ethereum wallet and any other client or contract that uses the same standards.</p>

<h4>The code</h4>

<p>If you just want to copy paste the code, then use this:</p>

<pre><code>pragma solidity ^0.4.8;
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract MyToken {
    /* Public variables of the token */
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* This notifies clients about the amount burnt */
    event Burn(address indexed from, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[msg.sender] &lt; _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /* Approve and then communicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[_from] &lt; _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw;  // Check for overflows
        if (_value &gt; allowance[_from][msg.sender]) throw;     // Check allowance
        balanceOf[_from] -= _value;                           // Subtract from the sender
        balanceOf[_to] += _value;                             // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] &lt; _value) throw;            // Check if the sender has enough
        balanceOf[msg.sender] -= _value;                      // Subtract from the sender
        totalSupply -= _value;                                // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] &lt; _value) throw;                // Check if the sender has enough
        if (_value &gt; allowance[_from][msg.sender]) throw;    // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        totalSupply -= _value;                               // Updates totalSupply
        Burn(_from, _value);
        return true;
    }
}</code></pre>

<h4>Minimum Viable Token</h4>

<p>The token contract is quite complex. But in essence a very basic token boils down to this:</p>

<pre><code>contract MyToken {
    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] &lt; _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
    }
}</code></pre>

<h4>Understanding the code</h4>

<p><img alt="Deploy New Contract" src="/images/tutorial/deploy-new-contract.png"/></p>

<p>So let&#39;s start with the basics. Open the <strong>Wallet</strong> app, go to the <em>Contracts</em> tab and then <em>Deploy New Contract</em>. On the <em>Solidity Contract Source code</em> text field, type the code below:</p>

<pre><code>contract MyToken {
    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;
}</code></pre>

<p>A mapping means an associative array, where you associate addresses with balances. The addresses are in the basic hexadecimal ethereum format, while the balances are integers, ranging from 0 to 115 quattuorvigintillion. If you don&#39;t know how much a quattuorvigintillion is, it&#39;s many vigintillions more than anything you are planning to use your tokens for. The <em>public</em> keyword, means that this variable will be accessible by anyone on the blockchain, meaning all balances are public (as they need to be, in order for clients to display them).</p>

<p><img alt="Edit New Contract" src="/images/tutorial/edit-contract.png"/></p>

<p>If you published your contract right away, it would work but wouldn&#39;t be very useful: it would be a contract that could query the balance of your coin for any addressâ€“but since you never created a single coin, every one of them would return 0. So we are going to create a few tokens on startup. Add this code <em>before</em> the last closing bracket, just under the <em>mapping..</em> line.</p>

<pre><code>function MyToken() {
    balanceOf[msg.sender] = 21000000;
}</code></pre>

<p>Notice that the <em>function MyToken</em> has the same name as the <em>contract MyToken</em>. This is very important and if you rename one, you have to rename the other too: this is a special, startup function that runs only once and once only when the contract is first uploaded to the network. This function will set the balance of <em>msg.sender</em>, the user which deployed the contract, with a balance of 21 million.</p>

<p>The choice of 21 million was rather arbitrary, and you can change it to anything you want in the code, but there&#39;s a better way: instead, supply it as a parameter for the function, like this:</p>

<pre><code>function MyToken(uint256 initialSupply) {
    balanceOf[msg.sender] = initialSupply;
}</code></pre>

<p>Take a look at the right column besides the contract and you&#39;ll see a drop down, written <em>pick a contract</em>. Select the &quot;MyToken&quot; contract and you&#39;ll see that now it shows a section called <em>Constructor parameters</em>. These are changeable parameters for your token, so you can reuse the same code and only change these variables in the future.</p>

<p><img alt="Edit New Contract" src="/images/tutorial/function-picker.png"/></p>

<p>Right now you have a functional contract that created balances of tokens but since there isn&#39;t any function to move it, all it does is stay on the same account. So we are going to implement that now. Write the following code <em>before the last bracket</em>.</p>

<pre><code>/* Send coins */
function transfer(address _to, uint256 _value) {
    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
}</code></pre>

<p>This is a very straightforward function: it has a recipient and a value as the parameter and whenever someone calls it, it will subtract the <em>_value</em> from their balance and add it to the <em>_to</em> balance. Right away there&#39;s an obvious problem: what happens if the person wants to send more than it owns? Since we don&#39;t want to handle debt in this particular contract, we are simply going to make a quick check and if the sender doesn&#39;t have enough funds the contract execution will simply stop. It&#39;s also to check for overflows, to avoid having a number so big that it becomes zero again.</p>

<p>To stop a contract execution mid execution you can either <strong>return</strong> or <strong>throw</strong> The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, &#39;throw&#39; will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any ether to be spent at all.</p>

<pre><code>function transfer(address _to, uint256 _value) {
    /* Check if sender has balance and for overflows */
    if (balanceOf[msg.sender] &lt; _value || balanceOf[_to] + _value &lt; balanceOf[_to])
        throw;

    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
}</code></pre>

<p>Now all that is missing is having some basic information about the contract. In the near future this can be handled by a token registry, but for now we&#39;ll add them directly to the contract:</p>

<pre><code>string public name;
string public symbol;
uint8 public decimals;</code></pre>

<p>And now we update the <strong>constructor function</strong> to allow all those variables to be set up at the start:</p>

<pre><code>/* Initializes contract with initial supply tokens to the creator of the contract */
function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) {
    balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
    name = tokenName;                                   // Set the name for display purposes
    symbol = tokenSymbol;                               // Set the symbol for display purposes
    decimals = decimalUnits;                            // Amount of decimals for display purposes
}</code></pre>

<p>Finally we now need something called <strong>Events</strong>. These are special, empty functions that you call to help clients like the Ethereum Wallet keep track of activities happening in the contract. Events should start with a capital letter. Add this line at the beginning of the contract to declare the event:</p>

<pre><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></pre>

<p>And then you just need to add these two lines inside the &quot;transfer&quot; function:</p>

<pre><code>    /* Notify anyone listening that this transfer took place */
    Transfer(msg.sender, _to, _value);</code></pre>

<p>And now your token is ready!</p>

<h4>How to deploy</h4>

<p>If you aren&#39;t there already, open the Ethereum Wallet, go to the contracts tab and then click &quot;deploy new contract&quot;.</p>

<p>Now get the token source from above and paste it into the &quot;Solidity source field&quot;. If the code compiles without any error, you should see a &quot;pick a contract&quot; drop down on the right. Get it and select the &quot;MyToken&quot; contract. On the right column you&#39;ll see all the parameters you need to personalize your own token. You can tweak them as you please, but for the purpose of this tutorial we recommend you to pick these parameters: 10,000 as the supply, any name you want, &quot;%&quot; for a symbol and 2 decimal places. Your app should be looking like this:</p>

<p><a href="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-10.png"><img alt="Ethereum Wallet Screenshot 2015-12-03 at 3.50.36 PM 10" src="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-10.png"/></a></p>

<p>Scroll to the end of the page and you&#39;ll see an estimate of the computation cost of that contract and you can select a fee on how much ether you are willing to pay for it. <strong>Any excess ether you don&#39;t spend will be returned to you</strong> so you can leave the default settings if you wish. Press &quot;deploy&quot;, type your account password and wait a few seconds for your transaction to be picked up.</p>

<p><a href="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-11.png"><img alt="Ethereum Wallet Screenshot 2015-12-03 at 3.50.36 PM 11" src="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-11.png"/></a></p>

<p>You&#39;ll be redirected to the front page where you can see your transaction waiting for confirmations. Click the account named &quot;Etherbase&quot; (your main account) and after no more than a minute you should see that your account will show that you have 100% of the shares you just created. Â To send some to a few friends: select &quot;send&quot;, and then choose which currency you want to send (ether or your newly created share), paste your friend&#39;s address on the &quot;to&quot; field and press &quot;send&quot;.</p>

<p><img alt="Screen Shot 2015-12-03 at 9.48.15 AM" src="/images/tutorial/Screen-Shot-2015-12-03-at-9.48.15-AM.png"/></p>

<p>If you send it to a friend, they will not see anything in their wallet yet. This is because the wallet only tracks tokens it knows about, and you have to add these manually. Now go to the &quot;Contracts&quot; tab and you should see a link for your newly created contract. Click on it to go to its page. Since this is a very simple contract page there isn&#39;t much to do here, just click &quot;copy address&quot; and paste the contract address on a text editor, you&#39;ll need it shortly.</p>

<p>To add a token to watch, go to the contracts page and then click &quot;Watch Token&quot;. A pop-up will appear and you only need to paste the contract address. The token name, symbol and decimal number should be automatically filled but if it&#39;s not you can put anything you want (it will only affect how it displays on your wallet). Once you do this, you&#39;ll automatically be shown any balance you have of that token and you&#39;ll be able to send it to anyone else.</p>

<p><a href="/images/tutorial/Screen-Shot-2015-12-03-at-9.44.42-AM.png"><img alt="Ethereum Wallet Beta 4 Screen Shot 2015-12-03 at 9.44.42 AM" src="/images/tutorial/Screen-Shot-2015-12-03-at-9.44.42-AM.png"/></a></p>

<p>And now you have your own crypto token! Tokens by themselves can be useful as <a href="https://en.wikipedia.org/wiki/Local_currency">value exchange on local communities</a>, ways to <a href="https://en.wikipedia.org/wiki/Time-based_currency">keep track of worked hours</a> or other loyalty programs. But can we make a currency have an intrinsic value by making it useful?</p>

<h3>Improve your token</h3>

<p>You can deploy your whole crypto token without ever touching a line of code, but the real magic happens when you start customizing it. The following sections will be suggestions on functions you can add to your token to make it fit your needs more.</p>

<h4>Centralized Administrator</h4>

<p>All dapps are fully decentralized by default, but that doesn&#39;t mean they can&#39;t have some sort of central manager, if you want them to. Maybe you want the ability to mint more coins, maybe you want to ban some people from using your currency. You can add any of those features, but the catch is that you can only add them at the beginning, so all the token holders will always know exactly the rules of the game before they decide to own one.</p>

<p>For that to happen, you need a central controller of currency. This could be a simple account, but could also be a contract and therefore the decision on creating more tokens will depend on the contract: if it&#39;s a democratic organization that can be up to vote, or maybe it can be just a way to limit the power of the token owner.</p>

<p>In order to do that we&#39;ll learn a very useful property of contracts: <strong>inheritance</strong>. Inheritance allows a contract to acquire properties of a parent contract, without having to redefine all of them. This makes the code cleaner and easier to reuse. Add this code to the first line of your code, <strong>before contract MyToken {</strong>.</p>

<pre><code>contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}</code></pre>

<p>This creates a very basic contract that doesn&#39;t do anything except define some generic functions about a contract that can be &quot;owned&quot;. Now the next step is just add the text <em>is owned</em> to your contract:</p>

<pre><code>contract MyToken is owned {
    /* the rest of the contract as usual */</code></pre>

<p>This means that all the functions inside <strong>MyToken</strong> now can access the variable <em>owner</em> and the modifier <em>onlyOwner</em>. The contract also gets a function to transfer ownership. Since it might be interesting to set the owner of the contract at startup, you can also add this to the <em>constructor function</em>:</p>

<pre><code>function MyToken(
    uint256 initialSupply,
    string tokenName,
    uint8 decimalUnits,
    string tokenSymbol,
    address centralMinter
    ) {
    if(centralMinter != 0 ) owner = centralMinter;
}</code></pre>

<h4>Central Mint</h4>

<p>Suppose you want the amount of coins in circulation to change. This is the case when your tokens actually represent an off blockchain asset (like gold certificates or government currencies) and you want the virtual inventory to reflect the real one. This might also be the case when the currency holders expect some control of the price of the token, and want to issue or remove tokens from circulation.</p>

<p>First we need to add a variable to store the <strong>totalSupply</strong> and assign it in our constructor function.</p>

<pre><code>contract MyToken {
    uint256 public totalSupply;

    function MyToken(...) {
        totalSupply = initialSupply;
        ...
    }
    ...
}</code></pre>

<p>Now let&#39;s add a new function finally that will enable the owner to create new tokens:</p>

<pre><code>function mintToken(address target, uint256 mintedAmount) onlyOwner {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(0, owner, mintedAmount);
    Transfer(owner, target, mintedAmount);
}</code></pre>

<p>Notice the modifier <strong>onlyOwner</strong> on the end of the function name. This means that this function will be rewritten at compilation to inherit the code from the <strong>modifier onlyOwner</strong> we had defined before. This function&#39;s code will be inserted where there&#39;s an underline on the modifier function, meaning that this particular function can only be called by the account that is set as the owner. Just add this to a contract with an <strong>owner</strong> modifier and you&#39;ll be able to create more coins.</p>

<h4>Freezing of assets</h4>

<p>Depending on your use case, you might need to have some regulatory hurdles on who can and cannot use your tokens. For that to happen, you can add a parameter that enables the contract owner to freeze or unfreeze assets.</p>

<p>Add this variable and function anywhere inside the contract. You can put them anywhere but for good practice we recommend you put the mappings with the other mappings and events with the other events.</p>

<pre><code>mapping (address =&gt; bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);

function freezeAccount(address target, bool freeze) onlyOwner {
    frozenAccount[target] = freeze;
    FrozenFunds(target, freeze);
}</code></pre>

<p>With this code, all accounts are unfrozen by default but the owner can set any of them into a freeze state by calling <strong>Freeze Account</strong>. Unfortunately freezing has no practical effect, because we haven&#39;t added anything to the transfer function. We are changing that now:</p>

<pre><code>function transfer(address _to, uint256 _value) {
    if (frozenAccount[msg.sender]) throw;</code></pre>

<p>Now any account that is frozen will still have their funds intact, but won&#39;t be able to move them. All accounts are unfrozen by default until you freeze them, but you can easily revert that behavior into a whitelist where you need to manually approve every account. Just rename <strong>frozenAccount</strong> into <strong>approvedAccount</strong> and change the last line to:</p>

<pre><code>    if (!approvedAccount[msg.sender]) throw;</code></pre>

<h4>Automatic selling and buying</h4>

<p>So far, you&#39;ve relied on utility and trust to value your token. But if you want you can make the token&#39;s value be backed by ether (or other tokens) by creating a fund that automatically sells and buys them at market value.</p>

<p>First, let&#39;s set the price for buying and selling:</p>

<pre><code>uint256 public sellPrice;
uint256 public buyPrice;

function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
    sellPrice = newSellPrice;
    buyPrice = newBuyPrice;
}</code></pre>

<p>This is acceptable for a price that doesn&#39;t change very often, as every new price change will require you to execute a transaction and spend a bit of ether. If you want to have a constant floating price we recommend investigating <a href="https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs#data-feeds">standard data feeds</a></p>

<p>The next step is making the buy and sell functions:</p>

<pre><code>function buy() payable returns (uint amount){
    amount = msg.value / buyPrice;                     // calculates the amount
    if (balanceOf[this] &lt; amount) throw;               // checks if it has enough to sell
    balanceOf[msg.sender] += amount;                   // adds the amount to buyer&#39;s balance
    balanceOf[this] -= amount;                         // subtracts amount from seller&#39;s balance
    Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    return amount;                                     // ends function and returns
}

function sell(uint amount) returns (uint revenue){
    if (balanceOf[msg.sender] &lt; amount ) throw;        // checks if the sender has enough to sell
    balanceOf[this] += amount;                         // adds the amount to owner&#39;s balance
    balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller&#39;s balance
    revenue = amount * sellPrice;
    if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it&#39;s important
        throw;                                         // to do this last to prevent recursion attacks
    } else {
        Transfer(msg.sender, this, amount);             // executes an event reflecting on the change
        return revenue;                                 // ends function and returns
    }
}</code></pre>

<p>Notice that this will not create new tokens but change the balance the contract owns. The contract can hold both its own tokens and ether and the owner of the contract, while it can set prices or in some cases create new tokens (if applicable) it cannot touch the bank&#39;s tokens or ether. The only way this contract can move funds is by selling and buying them.</p>

<p><strong>Note</strong> Buy and sell &quot;prices&quot; are not set in ether, but in <em>wei</em> the minimum currency of the system (equivalent to the cent in the Euro and Dollar, or the Satoshi in Bitcoin). One ether is 1000000000000000000 wei. So when setting prices for your token in ether, add 18 zeros at the end.</p>

<p>When creating the contract, <strong>send enough ether to it so that it can buy back all the tokens on the market</strong> otherwise your contract will be insolvent and your users won&#39;t be able to sell their tokens.</p>

<p>The previous examples, of course, describe a contract with a single central buyer and seller, a much more interesting contract would allow a market where anyone can bid different prices, or maybe it would load the prices directly from an external source.</p>

<h4>Autorefill</h4>

<p>Everytime you make a transaction on ethereum you need to pay a fee to the miner of the block that will calculate the result of your smart contract. <a href="https://github.com/ethereum/EIPs/issues/28">While this might change in the future</a>, for the moment fees can only be paid in ether and therefore all users of your tokens need it. Tokens in accounts with a balance smaller than the fee are stuck until the owner can pay for the necessary fee. But in some usecases, you might not want your users to think about ethereum, blockchain or how to obtain ether, so one possible approach would have your coin automatically refill the user balance as soon as it detects the balance is dangerously low.</p>

<p>In order to do that, first you need to create a variable that will hold the threshold amount and a function to change it. If you don&#39;t know any value, set it to <strong>5 finney (0.005 ether)</strong>.</p>

<pre><code>uint minBalanceForAccounts;

function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
     minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
}</code></pre>

<p>Then, add this line to the <strong>transfer</strong> function so that the sender is refunded:</p>

<pre><code>/* Send coins */
function transfer(address _to, uint256 _value) {
    ...
    if(msg.sender.balance&lt;minBalanceForAccounts)
        sell((minBalanceForAccounts-msg.sender.balance)/sellPrice);
}</code></pre>

<p>You can also instead change it so that the fee is paid forward to the receiver by the sender:</p>

<pre><code>/* Send coins */
function transfer(address _to, uint256 _value) {
    ...
    if(_to.balance&lt;minBalanceForAccounts)
        _to.send(sell((minBalanceForAccounts-_to.balance)/sellPrice));
}</code></pre>

<p>This will ensure that no account receiving the token has less than the necessary ether to pay the fees.</p>

<h4>Proof of Work</h4>

<p>There are some ways to tie your coin supply to a mathematical formula. One of the simplest ways would be to make it a &quot;merged mining&quot; with ether, meaning that anyone who finds a block on ethereum would also get a reward from your coin, given that anyone calls the reward function on that block. You can do it using the <a href="https://solidity.readthedocs.org/en/latest/units-and-global-variables.html#block-and-transaction-properties">special keyword coinbase</a> that refers to the miner who finds the block.</p>

<pre><code>function giveBlockReward() {
    balanceOf[block.coinbase] += 1;
}</code></pre>

<p>It&#39;s also possible to add a mathematical formula, so that anyone who can do math can win a reward. On this next example you have to calculate the cubic root of the current challenge gets a point and the right to set the next challenge:</p>

<pre><code>uint currentChallenge = 1; // Can you figure out the cubic root of this number?

function rewardMathGeniuses(uint answerToCurrentReward, uint nextChallenge) {
    if (answerToCurrentReward**3 != currentChallenge) throw; // If answer is wrong do not continue
    balanceOf[msg.sender] += 1;         // Reward the player
    currentChallenge = nextChallenge;   // Set the next challenge
}</code></pre>

<p>Of course while calculating cubic roots can be hard for someone to do on their heads, they are very easy with a calculator, so this game could be easily broken by a computer. Also since the last winner can choose the next challenge, they could pick something they know and therefore would not be a very fair game to other players. There are tasks that are easy for humans but hard for computers but they are usually very hard to code in simple scripts like these. Instead a fairer system should be one that is very hard for a computer to do, but isn&#39;t very hard for a computer to verify. A great candidate would be to create a hash challenge where the challenger has to generate hashes from multiple numbers until they find one that is lower than a given difficulty.</p>

<p>This process was first proposed by Adam Back in 1997 as <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a> and then was implemented in Bitcoin by Satoshi Nakamoto as <strong>Proof of work</strong> in 2008. Ethereum was launched using such system for its security model, but is planning to move from a Proof of Work security model into a <a href="https://blog.ethereum.org/2015/12/28/understanding-serenity-part-2-casper/">mixed proof of stake and betting system called <em>Casper</em></a>.</p>

<p>But if you like Hashing as a form of random issuance of coins, you can still create your own ethereum based currency that has a proof of work issuance:</p>

<pre><code>bytes32 public currentChallenge;                         // The coin starts with a challenge
uint public timeOfLastProof;                             // Variable to keep track of when rewards were given
uint public difficulty = 10**32;                         // Difficulty starts reasonably low

function proofOfWork(uint nonce){
    bytes8 n = bytes8(sha3(nonce, currentChallenge));    // Generate a random hash based on input
    if (n &lt; bytes8(difficulty)) throw;                   // Check if it&#39;s under the difficulty

    uint timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given
    if (timeSinceLastProof &lt;  5 seconds) throw;         // Rewards cannot be given too quickly
    balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute

    difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty

    timeOfLastProof = now;                              // Reset the counter
    currentChallenge = sha3(nonce, currentChallenge, block.blockhash(block.number-1));  // Save a hash that will be used as the next proof
}</code></pre>

<p>Also change the <strong>Constructor function</strong> (the one that has the same name as the contract, which is called at first upload) to add this line, so the difficulty adjustment will not go crazy:</p>

<pre><code>    timeOfLastProof = now;</code></pre>

<p>Once the contract is online, select the function &quot;Proof of work&quot;, add your favorite number on the <strong>nonce</strong> field and try to execute it. If the confirmation window gives a red warning saying <em>&quot;Data can&#39;t be execute&quot;</em> go back and pick another number until you find one that allows the transaction to go forward: this process is random. If you find one you will be awarded 1 token for every minute that has passed since the last reward was given, and then the challenge difficulty will be adjusted up or down to target an average of 10 minutes per reward.</p>

<p>This process of trying to find the number that will give you a reward is what is called <em>mining</em>: if difficulty rises it can be very hard to find a lucky number, but it will be always easy to verify that you found one.</p>

<h3>Improved Coin</h3>

<h4>Full coin code</h4>

<p>If you add all the advanced options, this is how the final code should look like:</p>

<p><img alt="Advanced Token" src="/images/tutorial/advanced-token-deploy.png"/></p>

<pre><code>pragma solidity ^0.4.2;
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }

contract token {
    /* Public variables of the token */
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] &lt; _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw; // Check for overflows
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /* Approve and then communicate the approved contract in a single tx */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] &lt; _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw;  // Check for overflows
        if (_value &gt; allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    /* This unnamed function is called whenever someone tries to send ether to it */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}

contract MyAdvancedToken is owned, token {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address =&gt; bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

    /* Send coins */
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] &lt; _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw; // Check for overflows
        if (frozenAccount[msg.sender]) throw;                // Check if frozen
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }


    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (frozenAccount[_from]) throw;                        // Check if frozen            
        if (balanceOf[_from] &lt; _value) throw;                 // Check if the sender has enough
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw;  // Check for overflows
        if (_value &gt; allowance[_from][msg.sender]) throw;   // Check allowance
        balanceOf[_from] -= _value;                          // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    function buy() payable {
        uint amount = msg.value / buyPrice;                // calculates the amount
        if (balanceOf[this] &lt; amount) throw;               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                   // adds the amount to buyer&#39;s balance
        balanceOf[this] -= amount;                         // subtracts amount from seller&#39;s balance
        Transfer(this, msg.sender, amount);                // execute an event reflecting the change
    }

    function sell(uint256 amount) {
        if (balanceOf[msg.sender] &lt; amount ) throw;        // checks if the sender has enough to sell
        balanceOf[this] += amount;                         // adds the amount to owner&#39;s balance
        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller&#39;s balance
        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It&#39;s important
            throw;                                         // to do this last to avoid recursion attacks
        } else {
            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
        }               
    }
}</code></pre>

<h4>Deploying</h4>

<p>Scroll down and you&#39;ll see an estimated cost for deployment. If you want you can change the slider to set a smaller fee, but if the price is too below the average market rate your transaction might take longer to pick up. Click <em>Deploy</em> and type your password. After a few seconds you&#39;ll be redirected to the dashboard and under <strong>Latest transactions</strong> you&#39;ll see a line saying &quot;creating contract&quot;. Wait for a few seconds for someone to pick your transaction and then you&#39;ll see a slow blue rectangle representing how many other nodes have seen your transaction and confirmed them. The more confirmations you have, the more assurance you have that your code has been deployed.</p>

<p><img alt="Created Token" src="/images/tutorial/created-token.png"/></p>

<p>Click on the link that says <em>Admin page</em> and you&#39;ll be taken the simplest central bank dashboard in the world,   where you can do anything you want with your newly created currency.</p>

<p>On the left side under <em>Read from contract</em> you have all the options and functions you can use to read information from the contract, for free. If your token has an owner, it will display its address here. Copy that address and paste it on <strong>Balance of</strong> and it will show you the balance of any account (the balance is also automatically shown on any account page that has tokens).</p>

<p>On the right side, under <strong>Write to Contract</strong> you&#39;ll see all the functions you can use to alter or change the blockchain in any way. These will cost gas. If you created a contract that allows you to mint new coins, you should have a function called &quot;Mint Token&quot;. Select it.</p>

<p><img alt="Manage central dollar" src="/images/tutorial/manage-central-dollar.png"/></p>

<p>Select the address where those new currencies will be created and then the amount (if you have decimals set at 2, then add 2 zeros after the amount, to create the correct quantity). On <strong>Execute from</strong> select the account that set as owner, leave the ether amount at zero and then press execute.</p>

<p>After a few confirmations, the recipient balance will be updated to reflect the new amount. But your recipient wallet might not show it automatically: in order to be aware of custom tokens, the wallet must add them manually to a watch list. Copy your token address (at the admin page, press <em>copy address</em>) and send that to your recipient. If they haven&#39;t already they should go to the contracts tab, press <strong>Watch Token</strong> and then add the address there. Name, symbols and decimal amounts displayed can be customized by the end user, especially if they have other tokens with similar (or the same) name. The main icon is not changeable and users should pay attention to them when sending and receiving tokens to ensure they are dealing with the real deal and not some copycat token.</p>

<p><img alt="add token" src="/images/tutorial/add-token.png"/></p>

<h2>Using your coin</h2>

<p>Once you&#39;ve deployed your tokens, they will be added to your list of watched tokens, and the total balance will be shown on your account. In order to send tokens, just go to the <strong>Send</strong> tab and select an account that contains tokens. The tokens the account has will be listed just under <em>Ether</em>. Select them and then type the amount of tokens you want to send.</p>

<p>If you want to add someone else&#39;s token, just go to the <strong>Contracts</strong> tab and click <strong>Watch token</strong>. For example, to add the <strong>Unicorn (ðŸ¦„)</strong> token to your watch list, just add the address <strong>0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7</strong> and the remaining information will be loaded automatically. Click <em>Ok</em> and your token will be added.</p>

<p><img alt="Invisible Unicorns" src="/images/tutorial/unicorn-token.png"/></p>

<p>Unicorn tokens are memorabilia created exclusively for those who have donated to the address <strong>0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359</strong> that is controlled by the Ethereum Foundation. For more information about them <a href="./donate">read it here</a></p>

<h3>Now what?</h3>

<p>You just learned how you can use ethereum to issue a token, that can represent anything you want. But what can you do with the tokens? You can use, for instance, the tokens to <a href="./dao#the-shareholder-association">represent a share in a company</a> or you can use a <a href="./dao#the-code">central committee</a> to vote on when to issue new coins to control inflation. You can also use them to raise money for a cause, via a <a href="./crowdsale">crowdsale</a>. What will you build next?</p><a href="https://github.com/ethereum/ethereum-org/edit/master/views/content/token.md" class="button small">Improve this page</a></div></div></div></div><div class="main-tutorial even"><div class="container"><div class="row"><div class="col-md-12 tutorial"><div class="col-md-12 tutorial"><h2>What's next?</h2></div><div class="col-md-6 tutorial"><figure class="crowdsale scrollme"><div data-when="enter" data-from="0.8" data-to="0.7" data-opacity="0" data-translatey="-100" data-easing="linear" class="crowdsale-logic animateme"></div><div data-when="enter" data-from="0.5" data-to="0.3" data-opacity="0" data-translatey="-155" data-translatex="-30" data-scale="1.1" data-rotatez="90" data-easing="linear" class="crowdsale-robot animateme"></div><div data-when="enter" data-from="0.8" data-to="0.6" data-opacity="0" data-translatey="-20" class="crowdsale-money animateme"></div><div data-when="enter" data-from="0.7" data-to="0.5" data-opacity="0" data-scale="1.4" class="crowdsale-contributions animateme"></div><div data-when="enter" data-from="0.3" data-to="0" data-opacity="0" data-translatey="-100" data-scale="1.1" data-easing="linear" class="crowdsale-crowd animateme"></div></figure></div><div class="col-md-6 tutorial">   <h3>Kickstart a project with a trustless crowdsale</h3><p>Do you already have ideas that you want to develop on Ethereum? Maybe you need help and some funds to bring them to life, but who would lend money to someone they donâ€™t trust?</p><p>Using Ethereum, you can create a contract that will hold a contributor's money until any given date or goal is reached. Depending on the outcome, the funds will either be released to the project owners or safely returned back to the contributors. All of this is possible without requiring a centralized arbitrator, clearing house or having to trust anyone.</p><p>You can even use the token you created earlier to keep track of the distribution of rewards.</p></div><div class="clearfix"></div><div class="col-md-6 tutorial"><a href="/crowdsale" class="button">Kickstart your project </a></div><div class="col-md-6 tutorial"><div class="recipe"><h4>You can build:</h4><ul><li>A crowdfund to pre-sell a product</li><li>A crowdsale to sell virtual shares in a blockchain organization</li><li>An auction of a limited number of items</li></ul></div></div></div></div></div></div><script> ((window.gitter = {}).chat = {}).options = {
   room: 'ethereum/tutorials'
 };</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><footer class="scrollme"><div class="footer"><div class="container"><div class="row"><div id="developer-resources" class="col-md-6 developers"><h2>Developer Resources</h2><ul><li>What is Ether? <a href="./ether">Read our FAQ</a></li><li>Source code on <a href="http://github.com/ethereum/">GitHub</a></li><li>Read the   <a href="http://www.ethdocs.org/">Homestead Documentation</a></li><li>Learn the  <a href="https://solidity.readthedocs.org/">Solidity Language</a></li><li>Learn more on the Ethereum  <a href="http://ethdocs.org/en/latest/">documentation  </a>and Ethereum  <a href="https://github.com/ethereum/go-ethereum/wiki/">Go  </a>Wiki</li><li>See latest data on <a href="https://ethstats.net">Network Stats</a></li><li>Download our <a href="assets">Logo assets </a></li><li>Want to write about us? <a href="mailto:press@ethereum.org ">Press inquiries</a></li></ul></div><div id="about-us" class="col-md-6"><h2>Ethereum Foundation</h2><p>Ethereum is developed by a worldwide team of passionate developers for the <a href="./foundation">Ethereum Foundation</a>, a Swiss nonprofit organization. </p><p> <a href="./donate" class="donate-button">Donate to support development </a><div class="caption">(and you can get a unicorn!)</div></p></div></div><div class="row"><div id="community" class="col-md-6 community"><h2>Community</h2><ul><li><a href="http://blog.ethereum.org">Blog</a></li><li><a href="http://twitter.com/ethereumproject" class="twitter">Twitter</a></li><li><a href="https://www.youtube.com/user/ethereumproject" class="youtube">Youtube</a></li><li><a href="http://www.reddit.com/r/ethereum" class="reddit">Reddit</a></li><li><a href="https://gitter.im/orgs/ethereum/rooms" class="gitter">Gitter</a></li><li><a href="http://ethereum.stackexchange.com" class="stackexchange">Stack Exchange</a></li><li><a href="https://www.facebook.com/ethereumproject" class="facebook">Facebook                </a></li><li><a href="http://ethereum.meetup.com" class="meetups">Meetups</a></li><li><a href="mailto:info@ethereum.org" class="email">Email us</a></li><li class="canary"><p>The Ethereum Foundation (Stiftung Ethereum) has never been contacted by any agency anywhere in the world in a way which requires that contact not to be disclosed.</p><p>Stiftung Ethereum will publicly disclose any sort of inquiry from government agencies that falls outside the scope of regular business operations.</p></li></ul></div><div id="news" class="col-md-6 news"><h2>Tweets</h2><a href="https://twitter.com/ethereumproject" data-widget-id="694952013856112640" data-chrome="nofooter noborders transparent noheader" height="360px" class="twitter-timeline">Tweets by @ethereumproject</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div></div><div class="col-md-12"><p class="copyright">Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland </p><p class="footer_links"> <a href="./privacy-policy">Privacy Policy </a>&nbsp; &nbsp; <a href="./cookie-policy">Cookie Policy</a>&nbsp; &nbsp; <a href="./terms-of-use">Terms of Use</a></p><p class="copyright">Copyright Â©2017 Ethereum Foundation. All Rights Reserved. </p></div></div></div></footer><script src="/js/frontier.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script>$(document).ready(function(){
    $("#toc").tableOfContents(
      $(".main-tutorial"),      // Scoped to div#wrapper
      {
        startLevel: 2,    // H2 and up
        depth:      3    // H2 through H4,
      }
    );
  });</script><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)
   },i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
   ga('create', 'UA-52040685-2', 'auto');
   ga('send', 'pageview');</script></body></html>