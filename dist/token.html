<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>Create a cryptocurrency contract in Ethereum</title><meta name="description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><meta name="twitter:card" value="summary"><meta property="og:title" content="Create a cryptocurrency contract in Ethereum"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ethereum.org/token"><meta property="og:image" content="/images/social-token.jpg"><meta property="og:image:width" content="500"><meta property="og:image:height" content="500"><meta property="og:description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,600,700,900,400italic|Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/app.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css"></head><body><div class="breadcrumb animateme" data-when="enter" data-from="1" data-to="0.8" data-opacity="0" data-translatey="-20"><a class="index" href="/">Ethereum</a><strong>»  Create your own crypto-currency</strong><a class="next" href="/crowdsale">Next</a></div><div class="main-tutorial token-tutorial inner-header inner-page even" id="tutorial-start"><div class="container"><div class="row"><div class="col-md-6 tutorial scrollme"><figure class="coin scrollme"><div class="coin-connection animateme" data-when="enter" data-to="1" data-from="0.5" data-opacity="0" data-translatey="0"></div><div class="coin-send animateme" data-when="enter" data-to="0.9" data-from="0.8" data-opacity="0" data-translatey="-50" data-translatex="-200"></div><div class="coin-users animateme" data-when="enter" data-to="0.5" data-from="0" data-opacity="0" data-translatey="-100" data-scale="1.5" data-rotate="45"></div><div class="coin-coins animateme" data-when="enter" data-to="0.6" data-from="0.4" data-opacity="0" data-scale="0.5" data-translatey="-10"></div></figure></div><div class="col-md-6 tutorial scrollme"><div class="header-title"><h3 class="animateme" data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear">Create your own</h3><h2 class="animateme" data-when="exit" data-from="0" data-to="1" data-translatey="400" data-easing="linear">crypto-currency</h2><h3 class="animateme" data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear">with Ethereum</h3></div></div></div></div></div><div class="main-tutorial inner-tutorial"><div class="container"><div class="row scrollme"><ul class="toc animateme" id="table-of-contents" data-when="enter" data-from="0.4" data-to="0.2" data-translatex="-100" data-opacity="0" data-easing="linear"></ul><div class="col-md-12"><h3>The Coin</h3>
<p>We are going to create a digital token. Tokens in the Ethereum ecosystem can represent any fungible tradable good: coins, loyalty points, gold certificates, IOUs, in-game items, etc. Since all tokens implement some basic features in a standard way, this also means that your token will be instantly compatible with the Ethereum wallet and any other client or contract that uses the same standards.</p>
<h4>Minimum Viable Token</h4>
<p>The standard token contract can be quite complex. But in essence a very basic token boils down to this:</p>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract MyToken {
    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;

    /* Initializes contract with initial supply tokens to the creator of the contract */
    constructor(
        uint256 initialSupply
        ) public {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &gt;= _value);           // Check if the sender has enough
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows
        balanceOf[msg.sender] -= _value;                    // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        return true;
    }
}

</code></pre>
<h4>The code</h4>
<p>But if you just want to copy paste a more complete code, then use this:</p>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

interface tokenRecipient { 
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&gt; uint256) public balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    // This generates a public event on the blockchain that will notify clients
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] &gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &gt;= _value);                // Check if the targeted balance is enough
        require(_value &lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}

</code></pre>
<h4>Understanding the code</h4>
<p><img src="/images/tutorial/deploy-new-contract.png" alt="Deploy New Contract"></p>
<p>So let's start with the basics. Open the <strong>Wallet</strong> app, go to the <em>Contracts</em> tab and then <em>Deploy New Contract</em>. On the <em>Solidity Contract Source code</em> text field, type the code below:</p>
<pre><code>    contract MyToken {
        /* This creates an array with all balances */
        mapping (address =&gt; uint256) public balanceOf;
    }
</code></pre>
<p>A mapping means an associative array, where you associate addresses with balances. The addresses are in the basic hexadecimal Ethereum format, while the balances are integers, ranging from 0 to 115 quattuorvigintillion. If you don't know how much a quattuorvigintillion is, it's many vigintillions more than anything you are planning to use your tokens for. The <em>public</em> keyword, means that this variable will be accessible by anyone on the blockchain, meaning all balances are public (as they need to be, in order for clients to display them).</p>
<p><img src="/images/tutorial/edit-contract.png" alt="Edit New Contract"></p>
<p>If you published your contract right away, it would work but wouldn't be very useful: it would be a contract that could query the balance of your coin for any address–but since you never created a single coin, every one of them would return 0. So we are going to create a few tokens on startup. Add this code <em>before</em> the last closing bracket, just under the <em>mapping..</em> line.</p>
<pre><code>    constructor() public {
        balanceOf[msg.sender] = 21000000;
    }
</code></pre>
<p>The constructor is a special startup function that runs only once and once only when the contract is first uploaded to the network. This function will set the balance of <em>msg.sender</em>, the user which deployed the contract, with a balance of 21 million.</p>
<p>The choice of 21 million was rather arbitrary, and you can change it to anything you want in the code, but there's a better way: instead, supply it as a parameter for the function, like this:</p>
<pre><code>    constructor(uint256 initialSupply) public {
        balanceOf[msg.sender] = initialSupply;
    }
</code></pre>
<p>Take a look at the right column beside the contract and you'll see a drop-down list, written <em>pick a contract</em>. Select the &quot;MyToken&quot; contract and you'll see that now it shows a section called <em>Constructor parameters</em>. These are changeable parameters for your token, so you can reuse the same code and only change these variables in the future.</p>
<p><img src="/images/tutorial/function-picker.png" alt="Edit New Contract"></p>
<p>Right now you have a functional contract that created balances of tokens but since there isn't any function to move it, all it does is stay on the same account. So we are going to implement that now. Write the following code <em>before the last bracket</em>.</p>
<pre><code>    /* Send coins */
    function transfer(address _to, uint256 _value) public {
        /* Add and subtract new balances */
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
    }
</code></pre>
<p>This is a very straightforward function: it has a recipient and a value as the parameter and whenever someone calls it, it will subtract the <em>_value</em> from their balance and add it to the <em>_to</em> balance. Right away there's an obvious problem: what happens if the person wants to send more than it owns? Since we don't want to handle debt in this particular contract, we are simply going to make a quick check and if the sender doesn't have enough funds the contract execution will simply stop. It's also to check for overflows, to avoid having a number so big that it becomes zero again.</p>
<p>To stop a contract execution mid-execution you can either <strong>return</strong> or <strong>throw</strong> The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, 'throw' will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all Ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any Ether to be spent at all.</p>
<pre><code>    function transfer(address _to, uint256 _value) public {
        /* Check if sender has balance and for overflows */
        require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);

        /* Add and subtract new balances */
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
    }
</code></pre>
<p>Now all that is missing is having some basic information about the contract. In the near future this can be handled by a token registry, but for now we'll add them directly to the contract:</p>
<pre><code>string public name;
string public symbol;
uint8 public decimals;
</code></pre>
<p>And now we update the <strong>constructor function</strong> to allow all those variables to be set up at the start:</p>
<pre><code>    /* Initializes contract with initial supply tokens to the creator of the contract */
    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits) public {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
</code></pre>
<p>Finally, we now need something called <strong>Events</strong>. These are special, empty functions that you call to help clients like the Ethereum Wallet keep track of activities happening in the contract. Events should start with a capital letter. Add this line at the beginning of the contract to declare the event:</p>
<pre><code>    event Transfer(address indexed from, address indexed to, uint256 value);
</code></pre>
<p>And then you just need to add these two lines inside the &quot;transfer&quot; function:</p>
<pre><code>        /* Notify anyone listening that this transfer took place */
        emit Transfer(msg.sender, _to, _value);
</code></pre>
<p>And now your token is ready!</p>
<h4>Noticed the comments?</h4>
<p>What are those @notice and @param comments, you might ask? That's <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format">Natspec</a> an emerging standard for a natural language specification, which allows wallets to show the user a natural language description of what the contract is about to do. While not currently supported by many wallets, this will change in the future, so it's nice to be prepared.</p>
<h4>How to deploy</h4>
<p>If you aren't there already, open the Ethereum Wallet, go to the contracts tab and then click &quot;deploy new contract&quot;.</p>
<p>Now get the token source from above and paste it into the &quot;Solidity source field&quot;. If the code compiles without any error, you should see a &quot;pick a contract&quot; drop-down list on the right. Get it and select the &quot;MyToken&quot; contract. On the right column, you'll see all the parameters you need to personalize your own token. You can tweak them as you please, but for the purpose of this tutorial we recommend you to pick these parameters: 10,000 as the supply, any name you want, &quot;%&quot; for a symbol and 2 decimal places. Your app should be looking like this:</p>
<p><a href="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-10.png"><img src="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-10.png" alt="Ethereum Wallet Screenshot 2015-12-03 at 3.50.36 PM 10"></a></p>
<p>Scroll to the end of the page and you'll see an estimate of the computation cost of that contract and you can select a fee on how much Ether you are willing to pay for it. <strong>Any excess Ether you don't spend will be returned to you</strong> so you can leave the default settings if you wish. Press &quot;deploy&quot;, type your account password and wait a few seconds for your transaction to be picked up.</p>
<p><a href="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-11.png"><img src="/images/tutorial/Ethereum-Wallet-Screenshot-2015-12-03-at-3.50.36-PM-11.png" alt="Ethereum Wallet Screenshot 2015-12-03 at 3.50.36 PM 11"></a></p>
<p>You'll be redirected to the front page where you can see your transaction waiting for confirmations. Click the account named &quot;Etherbase&quot; (your main account) and after no more than a minute you should see that your account will show that you have 100% of the shares you just created.  To send some to a few friends: select &quot;send&quot;, and then choose which currency you want to send (Ether or your newly created share), paste your friend's address on the &quot;to&quot; field and press &quot;send&quot;.</p>
<p><img src="/images/tutorial/Screen-Shot-2015-12-03-at-9.48.15-AM.png" alt="Screen Shot 2015-12-03 at 9.48.15 AM"></p>
<p>If you send it to a friend, they will not see anything in their wallet yet. This is because the wallet only tracks tokens it knows about, and you have to add these manually. Now go to the &quot;Contracts&quot; tab and you should see a link to your newly created contract. Click on it to go to its page. Since this is a very simple contract page there isn't much to do here, just click &quot;copy address&quot; and paste the contract address into a text editor, you'll need it shortly.</p>
<p>To add a token to watch, go to the contracts page and then click &quot;Watch Token&quot;. A pop-up will appear and you only need to paste the contract address. The token name, symbol and decimal number should be automatically filled but if it's not you can put anything you want (it will only affect how it displays on your wallet). Once you do this, you'll automatically be shown any balance you have of that token and you'll be able to send it to anyone else.</p>
<p><a href="/images/tutorial/Screen-Shot-2015-12-03-at-9.44.42-AM.png"><img src="/images/tutorial/Screen-Shot-2015-12-03-at-9.44.42-AM.png" alt="Ethereum Wallet Beta 4 Screen Shot 2015-12-03 at 9.44.42 AM"></a></p>
<p>And now you have your own crypto token! Tokens by themselves can be useful as <a href="https://en.wikipedia.org/wiki/Local_currency">value exchange on local communities</a>, ways to <a href="https://en.wikipedia.org/wiki/Time-based_currency">keep track of worked hours</a> or other loyalty programs. But can we make a currency have an intrinsic value by making it useful?</p>
<h3>Improve your token</h3>
<p>You can deploy your whole crypto token without ever touching a line of code, but the real magic happens when you start customizing it. The following sections will be suggestions on functions you can add to your token to make it fit your needs more.</p>
<h4>More basic functions</h4>
<p>You'll notice that there are some more functions in your basic token contract, like approve, sendFrom and others.
These functions are there for your token to interact with other contracts: if you want to, say, sell tokens to a decentralized exchange, just sending them to an address will not be enough as the exchange will not be aware of the new tokens or who sent them, because contracts aren't able to subscribe to <strong>Events</strong> only to <strong>function calls</strong>. So for contracts, you should first approve an amount of tokens they can move from your account and then ping them to let them know they should do their thing - or do the two actions in one, with <strong>approveAndCall</strong>.</p>
<p>Because many of these functions are having to reimplement the transferring of tokens, it makes sense to change them to an internal function, which can only be called by the contract itself:</p>
<pre><code>    /* Internal transfer, can only be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] &gt;= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value &gt;= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }
</code></pre>
<p>Now all your functions that result in the transfer of coins, can do their own checks and then call <strong>transfer</strong> with the correct parameters. Notice that this function will move coins from any account to any other, without requiring anyone's permission to do so: that's why it's an internal function, only called by the contract: if you add any function calling it, make sure it properly verifies if the caller should be have permission to move those.</p>
<h4>Centralized Administrator</h4>
<p>All dapps are fully decentralized by default, but that doesn't mean they can't have some sort of central manager, if you want them to. Maybe you want the ability to mint more coins, maybe you want to ban some people from using your currency. You can add any of those features, but the catch is that you can only add them at the beginning, so all the token holders will always know exactly the rules of the game before they decide to own one.</p>
<p>For that to happen, you need a central controller of currency. This could be a simple account, but could also be a contract and therefore the decision on creating more tokens will depend on the contract: if it's a democratic organization that can be up to vote, or maybe it can be just a way to limit the power of the token owner.</p>
<p>In order to do that we'll learn a very useful property of contracts: <strong>inheritance</strong>. Inheritance allows a contract to acquire properties of a parent contract, without having to redefine all of them. This makes the code cleaner and easier to reuse. Add this code to the first line of your code, before <strong>contract MyToken {</strong>.</p>
<pre><code>    contract owned {
        address public owner;

        constructor() {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) onlyOwner public {
            owner = newOwner;
        }
    }
</code></pre>
<p>This creates a very basic contract that doesn't do anything except define some generic functions about a contract that can be &quot;owned&quot;. Now the next step is just to add the text <em>is owned</em> to your contract:</p>
<pre><code>    contract MyToken is owned {
        /* the rest of the contract as usual */
</code></pre>
<p>This means that all the functions inside <strong>MyToken</strong> now can access the variable <em>owner</em> and the modifier <em>onlyOwner</em>. The contract also gets a function to transfer ownership. Since it might be interesting to set the owner of the contract at startup, you can also add this to the <em>constructor function</em>:</p>
<pre><code>    constructor(
        uint256 initialSupply,
        string memory tokenName,
        uint8 decimalUnits,
        string memory tokenSymbol,
        address centralMinter
        ) public {
        if(centralMinter != 0 ) owner = centralMinter;
    }
</code></pre>
<h4>Central Mint</h4>
<p>Suppose you want the amount of coins in circulation to change. This is the case when your tokens actually represent an off blockchain asset (like gold certificates or government currencies) and you want the virtual inventory to reflect the real one. This might also be the case when the currency holders expect some control of the price of the token, and want to issue or remove tokens from circulation.</p>
<p>First, we need to add a variable to store the <strong>totalSupply</strong> and assign it to our constructor function.</p>
<pre><code>    contract MyToken {
        uint256 public totalSupply;

        constructor(...) public {
            totalSupply = initialSupply;
            ...
        }
        ...
    }
</code></pre>
<p>Now let's add a new function finally that will enable the owner to create new tokens:</p>
<pre><code>    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(0, owner, mintedAmount);
        emit Transfer(owner, target, mintedAmount);
    }
</code></pre>
<p>Notice the modifier <strong>onlyOwner</strong> on the end of the function name. This means that this function will be rewritten at compilation to inherit the code from the <strong>modifier onlyOwner</strong> we had defined before. This function's code will be inserted where there's an underline on the modifier function, meaning that this particular function can only be called by the account that is set as the owner. Just add this to a contract with an <strong>owner</strong> modifier and you'll be able to create more coins.</p>
<h4>Freezing of assets</h4>
<p>Depending on your use case, you might need to have some regulatory hurdles on who can and cannot use your tokens. For that to happen, you can add a parameter that enables the contract owner to freeze or unfreeze assets.</p>
<p>Add this variable and function anywhere inside the contract. You can put them anywhere but for good practice we recommend you put the mappings with the other mappings and events with the other events.</p>
<pre><code>    mapping (address =&gt; bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
</code></pre>
<p>With this code, all accounts are unfrozen by default but the owner can set any of them into a freeze state by calling <strong>Freeze Account</strong>. Freezing does not yet have a practical effect because we haven't added anything to the transfer function. We are changing that now:</p>
<pre><code>    function transfer(address _to, uint256 _value) public {
        require(!frozenAccount[msg.sender]);
</code></pre>
<p>Now any account that is frozen will still have their funds intact, but won't be able to move them. Alternatively, you can also create a whitelist where all accounts are frozen by default and each account needs to be manually approved. Just rename <strong>frozenAccount</strong> into <strong>approvedAccount</strong> and change the last line to:</p>
<pre><code>        require(approvedAccount[msg.sender]);
</code></pre>
<h4>Automatic selling and buying</h4>
<p>So far, you've relied on utility and trust to value your token. But if you want you can make the token's value be backed by Ether (or other tokens) by creating a fund that automatically sells and buys them at market value.</p>
<p>First, let's set the price for buying and selling:</p>
<pre><code>    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
</code></pre>
<p>This is acceptable for a price that doesn't change very often, as every new price change will require you to execute a transaction and spend a bit of Ether. If you want to have a constant floating price we recommend investigating <a href="https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs#data-feeds">standard data feeds</a></p>
<p>The next step is making the buy and sell functions:</p>
<pre><code>    function buy() public payable returns (uint amount) {
        amount = msg.value / buyPrice;                    // calculates the amount
        _transfer(address(this), msg.sender, amount);
        return amount;
    }

    function sell(uint amount) public returns (uint revenue) {
        require(balanceOf[msg.sender] &gt;= amount);         // checks if the sender has enough to sell
        balanceOf[address(this)] += amount;               // adds the amount to owner's balance
        balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks
        emit Transfer(msg.sender, address(this), amount); // executes an event reflecting on the change
        return revenue;                                   // ends function and returns
    }
</code></pre>
<p>Notice that this will not create new tokens but change the balance the contract owns. The contract can hold both its own tokens and Ether and the owner of the contract, while it can set prices or in some cases create new tokens (if applicable) it cannot touch the bank's tokens or Ether. The only way this contract can move funds is by selling and buying them.</p>
<p><strong>Note</strong> Buy and sell &quot;prices&quot; are not set in Ether, but in <em>wei</em> the minimum currency of the system (equivalent to the cent in the Euro and Dollar, or the Satoshi in Bitcoin). One Ether is 1000000000000000000 wei. So when setting prices for your token in Ether, add 18 zeros at the end.</p>
<p>When creating the contract, <strong>send enough Ether to it so that it can buy back all the tokens on the market</strong> otherwise your contract will be insolvent and your users won't be able to sell their tokens.</p>
<p>The previous examples, of course, describe a contract with a single central buyer and seller, a much more interesting contract would allow a market where anyone can bid different prices, or maybe it would load the prices directly from an external source.</p>
<h4>Autorefill</h4>
<p>Everytime, you make a transaction on Ethereum you need to pay a fee to the miner of the block that will calculate the result of your smart contract. <a href="https://github.com/ethereum/EIPs/issues/28">While this might change in the future</a>, for the moment fees can only be paid in Ether and therefore all users of your tokens need it. Tokens in accounts with a balance smaller than the fee are stuck until the owner can pay for the necessary fee. But in some use cases, you might not want your users to think about Ethereum, blockchain or how to obtain Ether, so one possible approach would have your coin automatically refill the user balance as soon as it detects the balance is dangerously low.</p>
<p>In order to do that, first you need to create a variable that will hold the threshold amount and a function to change it. If you don't know any value, set it to <strong>5 finney (0.005 Ether)</strong>.</p>
<pre><code>    uint public minBalanceForAccounts;

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner public {
         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
    }
</code></pre>
<p>Then, add this line to the <strong>transfer</strong> function so that the sender is refunded:</p>
<pre><code>    /* Send coins */
    function transfer(address _to, uint256 _value) public {
        ...
        if(msg.sender.balance &lt; minBalanceForAccounts)
            sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);
    }
</code></pre>
<p>You can also instead change it so that the fee is paid forward to the receiver by the sender:</p>
<pre><code>    /* Send coins */
    function transfer(address _to, uint256 _value) public {
        ...
        if(_to.balance&lt;minBalanceForAccounts)
            _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));
    }
</code></pre>
<p>This will ensure that no account receiving the token has less than the necessary Ether to pay the fees.</p>
<h4>Proof of Work</h4>
<p>There are some ways to tie your coin supply to a mathematical formula. One of the simplest ways would be to make it a &quot;merged mining&quot; with Ether, meaning that anyone who finds a block on Ethereum would also get a reward from your coin, given that anyone calls the reward function on that block. You can do it using the <a href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties">special keyword coinbase</a> that refers to the miner who finds the block.</p>
<pre><code>    function giveBlockReward() public {
        balanceOf[block.coinbase] += 1;
    }
</code></pre>
<p>It's also possible to add a mathematical formula, so that anyone who can do math can win a reward. On this next example you have to calculate the cubic root of the current challenge gets a point and the right to set the next challenge:</p>
<pre><code>    uint public currentChallenge = 1; // Can you figure out the cubic root of this number?

    function rewardMathGeniuses(uint answerToCurrentReward, uint nextChallenge) public {
        require(answerToCurrentReward**3 == currentChallenge);  // If answer is wrong do not continue
        balanceOf[msg.sender] += 1;                             // Reward the player
        currentChallenge = nextChallenge;                       // Set the next challenge
    }
</code></pre>
<p>Of course, while calculating cubic roots can be hard for someone to do on their heads, they are very easy with a calculator, so this game could be easily broken by a computer. Also since the last winner can choose the next challenge, they could pick something they know and therefore would not be a very fair game to other players. There are tasks that are easy for humans but hard for computers but they are usually very hard to code in simple scripts like these. Instead, a fairer system should be one that is very hard for a computer to do, but isn't very hard for a computer to verify. A great candidate would be to create a hash challenge where the challenger has to generate hashes from multiple numbers until they find one that is lower than a given difficulty.</p>
<p>This process was first proposed by Adam Back in 1997 as <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a> and then was implemented in Bitcoin by Satoshi Nakamoto as <strong>Proof of work</strong> in 2008. Ethereum was launched using such system for its security model, but is planning to move from a Proof of Work security model into a <a href="https://blog.ethereum.org/2015/12/28/understanding-serenity-part-2-casper/">mixed proof of stake and betting system called <em>Casper</em></a>.</p>
<p>But if you like Hashing as a form of random issuance of coins, you can still create your own Ethereum based currency that has a proof of work issuance:</p>
<pre><code>    bytes32 public currentChallenge;    // The coin starts with a challenge
    uint public timeOfLastProof;        // Variable to keep track of when rewards were given
    uint public difficulty = 10**32;    // Difficulty starts reasonably low

    function proofOfWork(uint nonce) public {
        // Generate a random hash based on input
        bytes32 n = bytes32(keccak256(abi.encodePacked(nonce, currentChallenge)));
        require(n &gt;= bytes32(difficulty));                                  // Check if it's under the difficulty

        uint timeSinceLastProof = (now - timeOfLastProof);                  // Calculate time since last reward was given
        require(timeSinceLastProof &gt;=  5 seconds);                          // Rewards cannot be given too quickly
        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;           // The reward to the winner grows by the minute

        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;      // Adjusts the difficulty
        timeOfLastProof = now;                                              // Reset the counter
        
        // Save a hash that will be used as the next proof
        currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));
    }
</code></pre>
<p>Also change the <strong>Constructor function</strong> (the one that has the same name as the contract, which is called at first upload) to add this line, so the difficulty adjustment will not go crazy:</p>
<pre><code>    timeOfLastProof = now;
</code></pre>
<p>Once the contract is online, select the function &quot;Proof of work&quot;, add your favorite number on the <strong>nonce</strong> field and try to execute it. If the confirmation window gives a red warning saying <em>&quot;Data can't be execute&quot;</em> go back and pick another number until you find one that allows the transaction to go forward: this process is random. If you find one you will be awarded 1 token for every minute that has passed since the last reward was given, and then the challenge difficulty will be adjusted up or down to target an average of 10 minutes per reward.</p>
<p>This process of trying to find the number that will give you a reward is what is called <em>mining</em>: if difficulty rises it can be very hard to find a lucky number, but it will always be easy to verify that you found one.</p>
<h3>Improved Coin</h3>
<h4>Full coin code</h4>
<p>If you add all the advanced options, this is how the final code should look like:</p>
<p><img src="/images/tutorial/advanced-token-deploy.png" alt="Advanced Token"></p>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&gt; uint256) public balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    // This generates a public event on the blockchain that will notify clients
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens
        name = tokenName;                                       // Set the name for display purposes
        symbol = tokenSymbol;                                   // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != address(0x0));
        // Check if the sender has enough
        require(balanceOf[_from] &gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &gt; balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &gt;= _value);                // Check if the targeted balance is enough
        require(_value &lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}

/******************************************/
/*       ADVANCED TOKEN STARTS HERE       */
/******************************************/

contract MyAdvancedToken is owned, TokenERC20 {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address =&gt; bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] &gt;= _value);                   // Check if the sender has enough
        require (balanceOf[_to] + _value &gt;= balanceOf[_to]);    // Check for overflows
        require(!frozenAccount[_from]);                         // Check if sender is frozen
        require(!frozenAccount[_to]);                           // Check if recipient is frozen
        balanceOf[_from] -= _value;                             // Subtract from the sender
        balanceOf[_to] += _value;                               // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending &amp; receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 // calculates the amount
        _transfer(address(this), msg.sender, amount);       // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance &gt;= amount * sellPrice);   // checks if the contract has enough ether to buy
        _transfer(msg.sender, address(this), amount);       // makes the transfers
        msg.sender.transfer(amount * sellPrice);            // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
}


</code></pre>
<h4>Deploying</h4>
<p>Scroll down and you'll see an estimated cost for deployment. If you want you can change the slider to set a smaller fee, but if the price is too below the average market rate your transaction might take longer to pick up. Click <em>Deploy</em> and type your password. After a few seconds you'll be redirected to the dashboard and under <strong>Latest transactions</strong> you'll see a line saying &quot;creating contract&quot;. Wait for a few seconds for someone to pick your transaction and then you'll see a slow blue rectangle representing how many other nodes have seen your transaction and confirmed them. The more confirmations you have, the more assurance you have that your code has been deployed.</p>
<p><img src="/images/tutorial/created-token.png" alt="Created Token"></p>
<p>Click on the link that says <em>Admin page</em> and you'll be taken the simplest central bank dashboard in the world,   where you can do anything you want with your newly created currency.</p>
<p>On the left side under <em>Read from contract</em> you have all the options and functions you can use to read information from the contract, for free. If your token has an owner, it will display its address here. Copy that address and paste it into <strong>Balance of</strong> and it will show you the balance of any account (the balance is also automatically shown on any account page that has tokens).</p>
<p>On the right side, under <strong>Write to Contract</strong> you'll see all the functions you can use to alter or change the blockchain in any way. These will cost gas. If you created a contract that allows you to mint new coins, you should have a function called &quot;Mint Token&quot;. Select it.</p>
<p><img src="/images/tutorial/manage-central-dollar.png" alt="Manage central dollar"></p>
<p>Select the address where those new currencies will be created and then the amount (if you have decimals set at 2, then add 2 zeros after the amount, to create the correct quantity). On <strong>Execute from</strong> select the account that set as owner, leave the Ether amount at zero and then press execute.</p>
<p>After a few confirmations, the recipient balance will be updated to reflect the new amount. But your recipient wallet might not show it automatically: in order to be aware of custom tokens, the wallet must add them manually to a watch list. Copy your token address (at the admin page, press <em>copy address</em>) and send that to your recipient. If they haven't already they should go to the contracts tab, press <strong>Watch Token</strong> and then add the address there. Name, symbols and decimal amounts displayed can be customized by the end user, especially if they have other tokens with similar (or the same) name. The main icon is not changeable and users should pay attention to them when sending and receiving tokens to ensure they are dealing with the real deal and not some copycat token.</p>
<p><img src="/images/tutorial/add-token.png" alt="add token"></p>
<h2>Using your coin</h2>
<p>Once you've deployed your tokens, they will be added to your list of watched tokens, and the total balance will be shown on your account. In order to send tokens, just go to the <strong>Send</strong> tab and select an account that contains tokens. The tokens the account has will be listed just under <em>Ether</em>. Select them and then type the amount of tokens you want to send.</p>
<p>If you want to add someone else's token, just go to the <strong>Contracts</strong> tab and click <strong>Watch token</strong>. For example, to add the <strong>Unicorn (🦄)</strong> token to your watch list, just add the address <strong>0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7</strong> and the remaining information will be loaded automatically. Click <em>Ok</em> and your token will be added.</p>
<p><img src="/images/tutorial/unicorn-token.png" alt="Invisible Unicorns"></p>
<p>Unicorn tokens are memorabilia created exclusively for those who have donated to the address <strong>0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359</strong> that is controlled by the Ethereum Foundation. For more information about them <a href="./donate">read it here</a></p>
<h3>Now what?</h3>
<p>You just learned how you can use Ethereum to issue a token, that can represent anything you want. But what can you do with the tokens? You can use, for instance, the tokens to <a href="./dao#the-shareholder-association">represent a share in a company</a> or you can use a <a href="./dao#the-code">central committee</a> to vote on when to issue new coins to control inflation. You can also use them to raise money for a cause, via a <a href="./crowdsale">crowdsale</a>. What will you build next?</p>
<a class="button small" href="https://github.com/ethereum/ethereum-org/edit/master/views/content/token.md">Improve this page</a></div></div></div></div><div class="main-tutorial even"><div class="container"><div class="row"><div class="col-md-12 tutorial"><h2>What's next?</h2><div class="row"><div class="col-md-6"><figure class="crowdsale scrollme"><div class="crowdsale-logic animateme" data-when="enter" data-from="0.8" data-to="0.7" data-opacity="0" data-translatey="-100" data-easing="linear"></div><div class="crowdsale-robot animateme" data-when="enter" data-from="0.5" data-to="0.3" data-opacity="0" data-translatey="-155" data-translatex="-30" data-scale="1.1" data-rotatez="90" data-easing="linear"></div><div class="crowdsale-money animateme" data-when="enter" data-from="0.8" data-to="0.6" data-opacity="0" data-translatey="-20"></div><div class="crowdsale-contributions animateme" data-when="enter" data-from="0.7" data-to="0.5" data-opacity="0" data-scale="1.4"></div><div class="crowdsale-crowd animateme" data-when="enter" data-from="0.3" data-to="0" data-opacity="0" data-translatey="-100" data-scale="1.1" data-easing="linear"></div></figure></div><div class="col-md-6">   <h3>Kickstart a project with a trustless crowdsale</h3><p>Do you already have ideas that you want to develop on Ethereum? Maybe you need help and some funds to bring them to life, but who would lend money to someone they don’t trust?</p><p>Using Ethereum, you can create a contract that will hold a contributor's money until any given date or goal is reached. Depending on the outcome, the funds will either be released to the project owners or safely returned back to the contributors. All of this is possible without requiring a centralized arbitrator, clearinghouse or having to trust anyone.</p><p>You can even use the token you created earlier to keep track of the distribution of rewards.</p></div></div><div class="row"><div class="col-md-6"><a class="button" href="/crowdsale">Kickstart your project </a></div><div class="col-md-6"><div class="recipe"><h4>You can build:</h4><ul><li>A crowdfund to pre-sell a product</li><li>A crowdsale to sell virtual shares in a blockchain organization</li><li>An auction of a limited number of items</li></ul></div></div></div></div></div></div></div><footer class="scrollme"><div class="footer"><div class="container"><div class="row row-footer-news"><div class="col-md-12 news"><h3>News</h3><div class="iframe-wrapper"><a class="twitter-timeline" href="https://twitter.com/ethereum" data-widget-id="694952013856112640" data-chrome="nofooter noborders transparent noheader" data-theme="dark" width="100%" height="370px">Tweets by @ethereum</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div></div></div><div class="row row-footer-primary"><div class="col-md-4 community"><h3>Community</h3><div class="row"><div class="col-sm-5"><ul><li><a href="https://blog.ethereum.org" target="_blank"><i class="fa fa-rss"></i> Blog</a></li><li><a href="https://github.com/ethereum" target="_blank"><i class="fa fa-github"></i> GitHub</a></li><li><a href="https://www.youtube.com/user/ethereumproject" target="_blank"><i class="fa fa-youtube"></i> YouTube</a></li><li><a href="https://www.reddit.com/r/ethereum" target="_blank"><i class="fa fa-reddit"></i> Reddit</a></li><li><a href="https://gitter.im/orgs/ethereum/rooms" target="_blank"><i class="fa fa-comments-o"></i> Gitter</a></li></ul></div><div class="col-sm-7"><ul><li><a href="https://twitter.com/ethereum" target="_blank"><i class="fa fa-twitter"></i> Twitter</a></li><li><a href="https://ethereum.stackexchange.com" target="_blank"><i class="fa fa-stack-exchange"></i> Stack Exchange</a></li><li><a href="https://www.facebook.com/ethereumproject" target="_blank"><i class="fa fa-facebook"></i> Facebook</a></li><li><a href="https://ethereum.meetup.com" target="_blank"><i class="fa fa-meetup"></i> Meetups</a></li></ul></div></div></div><div class="col-md-4 about-us"><h3>Ethereum Foundation</h3><p>Ethereum is developed by a worldwide team of passionate developers for the&nbsp<a href="http://ethereum.foundation">Ethereum Foundation</a>, a Swiss nonprofit organization.</p><p><a class="donate-button" href="./donate">Donate to support development&nbsp</a><div class="caption">(and you can get a unicorn!)</div></p></div><div class="col-md-4 developer-resources"><h3>Developer Resources</h3><ul><li>What is Ether?&nbsp<a href="./ether">Read our FAQ</a></li><li>Browse our source code on&nbsp<a href="https://github.com/ethereum/" target="_blank">GitHub</a></li><li>Read the&nbsp<a href="http://www.ethdocs.org/" target="_blank">documentation</a>
or&nbsp<a href="https://github.com/ethereum/wiki/wiki" target="_blank">wiki</a></li><li>Learn&nbsp<a href="https://solidity.readthedocs.org/" target="_blank">Solidity</a></li><li>See the latest&nbsp<a href="https://ethstats.net" target="_blank">data and network stats</a></li><li>Download our&nbsp<a href="./assets">logo assets</a></li><li>Want to write about Ethereum?&nbsp<a href="mailto:press@ethereum.org">Press inquiries</a></li></ul></div></div><div class="row row-footer-copyright"><div class="col-md-12"><p class="copyright">Copyright &copy; 2018 Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland. All Rights Reserved.</p><p class="footer-links"><a href="./privacy-policy">Privacy Policy</a>&nbsp; &nbsp;<a href="./cookie-policy">Cookie Policy</a>&nbsp; &nbsp;<a href="./terms-of-use">Terms of Use</a></p></div></div><div class="row row-footer-canary"><div class="col-md-12"><div class="canary"><p>The Ethereum Foundation (Stiftung Ethereum) has never been contacted by any agency anywhere in the world in a way which requires that contact not to be disclosed.</p><p>Stiftung Ethereum will publicly disclose any sort of inquiry from government agencies that falls outside the scope of regular business operations.</p></div></div></div></div></div></footer><script src="/js/app.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script>$(document).ready(function(){
    $("#toc").tableOfContents(
      $(".main-tutorial"),      // Scoped to div#wrapper
      {
        startLevel: 2,    // H2 and up
        depth:      3    // H2 through H4,
      }
    );
  });</script><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)
   },i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
   ga('create', 'UA-52040685-2', 'auto');
   ga('send', 'pageview');</script></body></html>