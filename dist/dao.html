<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>Create a Democracy contract in Ethereum</title><meta name="description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><meta name="twitter:card" value="summary"><meta property="og:title" content="Create a Democracy contract in Ethereum"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ethereum.org/dao"><meta property="og:image" content="/images/social-dao.jpg"><meta property="og:image:width" content="500"><meta property="og:image:height" content="500"><meta property="og:description" content="Ethereum is a decentralized platform for applications that run exactly as programmed without any chance of fraud, censorship or third-party interference."><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,600,700,900,400italic|Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/app.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css"></head><body><div class="breadcrumb animateme" data-when="enter" data-from="1" data-to="0.8" data-opacity="0" data-translatey="-20"><a class="index" href="/">Ethereum </a><strong>»  Start a democratic organization</strong><a class="previous" href="/crowdsale">Previous</a></div><div class="main-tutorial dao-tutorial inner-header inner-page even" id="tutorial-start"><div class="container"><div class="row"><div class="col-md-6 tutorial scrollme"><figure class="dao scrollme"><div class="dao-robot animateme" data-when="exit" data-to="0.65" data-from="0.1" data-opacity="0" data-translatey="400" data-rotatez="-90"></div><div class="dao-money animateme" data-when="exit" data-to="0.7" data-from="0.0" data-opacity="0" data-translatey="200"></div><div class="dao-arrows animateme" data-when="exit" data-to="0.1" data-from="0" data-opacity="0" data-scale="0.75"></div><div class="dao-crowd animateme" data-when="exit" data-to="0.45" data-from="0" data-opacity="0" data-translatey="-250" data-translatex="10" data-rotatez="0" data-scale="1.1" data-easing="linear"></div><div class="dao-ideas animateme" data-when="exit" data-to="0.3" data-from="0.1" data-opacity="0" data-scale="2"></div></figure></div><div class="col-md-6 tutorial scrollme"><div class="header-title"><h3 class="animateme" data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear">How to build a </h3><h2 class="animateme" data-when="exit" data-from="0" data-to="1" data-translatey="400" data-easing="linear">Democracy</h2><h3 class="animateme" data-when="exit" data-from="0" data-to="0.5" data-translatey="200" data-opacity="0" data-easing="linear">on the blockchain</h3></div></div></div></div></div><div class="main-tutorial inner-tutorial"><div class="container"><div class="row scrollme"><ul class="toc animateme" id="table-of-contents" data-when="enter" data-from="0.4" data-to="0.2" data-translatex="-100" data-opacity="0" data-easing="linear"></ul><div class="col-md-12"><h2>Decentralized Autonomous Organization</h2>
<blockquote>
<p><strong>&quot;On the Blockchain, no one knows you're a fridge&quot;</strong></p>
<ul>
<li>Richard Brown</li>
</ul>
</blockquote>
<p>So far, all contracts we listed were owned and executed by other accounts probably held by humans. But there is no discrimination against robots or humans in the Ethereum ecosystem and contracts can create arbitrary actions like any other account would. Contracts can own tokens, participate in crowdsales, and even be voting members of other contracts.</p>
<p>In this section we are going to build a decentralized and democratic organization that exists solely on the blockchain, but that can do anything that a simple account would be able to. The organization has a central manager that decides who are the members and the voting rules, but as we'll see, this can also be changed.</p>
<p>The way this particular democracy works is that it has an <strong>Owner</strong> which works like an administrator, CEO or a President. The <em>Owner</em> can add (or remove) voting members to the organization. Any member can make a proposal, which is in the form of an ethereum transaction to either send ether or execute some contract, and other members can vote in support or against the proposal. Once a predetermined amount of time and a certain number of members has voted, the proposal can be executed: the contract counts the votes and if there are enough votes it will execute the given transaction.</p>
<h3>The Blockchain Congress</h3>
<h4>The code</h4>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner  public {
        owner = newOwner;
    }
}

contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable external {
        emit receivedEther(msg.sender, msg.value);
    }
}

interface Token {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract Congress is owned, tokenRecipient {
    // Contract Variables and events
    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    int public majorityMargin;
    Proposal[] public proposals;
    uint public numProposals;
    mapping (address =&gt; uint) public memberId;
    Member[] public members;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter, string justification);
    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);
    event MembershipChanged(address member, bool isMember);
    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint minExecutionDate;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        int currentResult;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address =&gt; bool) voted;
    }

    struct Member {
        address member;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    // Modifier that allows only shareholders to vote and create new proposals
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }

    /**
     * Constructor
     */
    constructor (
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority
    )  payable public {
        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
        // It’s necessary to add an empty first member
        addMember(address(0), &quot;&quot;);
        // and let's add the founder, to save a step later
        addMember(owner, 'founder');
    }

    /**
     * Add member
     *
     * Make `targetMember` a member named `memberName`
     *
     * @param targetMember ethereum address to be added
     * @param memberName public name for that member
     */
    function addMember(address targetMember, string memory memberName) onlyOwner public {
        uint id = memberId[targetMember];
        if (id == 0) {
            memberId[targetMember] = members.length;
            id = members.length++;
        }

        members[id] = Member({member: targetMember, memberSince: now, name: memberName});
        emit MembershipChanged(targetMember, true);
    }

    /**
     * Remove member
     *
     * @notice Remove membership from `targetMember`
     *
     * @param targetMember ethereum address to be removed
     */
    function removeMember(address targetMember) onlyOwner public {
        require(memberId[targetMember] != 0);

        for (uint i = memberId[targetMember]; i&lt;members.length-1; i++){
            members[i] = members[i+1];
            memberId[members[i].member] = i;
        }
        memberId[targetMember] = 0;
        delete members[members.length-1];
        members.length--;
    }

    /**
     * Change voting rules
     *
     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,
     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed
     *
     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed
     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed
     * @param marginOfVotesForMajority the proposal needs to have 50% plus this number
     */
    function changeVotingRules(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority
    ) onlyOwner public {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;

        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }

    /**
     * Add Proposal
     *
     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     *
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send, in wei
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposal(
        address beneficiary,
        uint weiAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyMembers public
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = weiAmount;
        p.description = jobDescription;
        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);
        numProposals = proposalID+1;

        return proposalID;
    }

    /**
     * Add proposal in Ether
     *
     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     * This is a convenience function to use if the amount to be given is in round number of ether units.
     *
     * @param beneficiary who to send the ether to
     * @param etherAmount amount of ether to send
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposalInEther(
        address beneficiary,
        uint etherAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyMembers public
        returns (uint proposalID)
    {
        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);
    }

    /**
     * Check if a proposal code matches
     *
     * @param proposalNumber ID number of the proposal to query
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send
     * @param transactionBytecode bytecode of transaction
     */
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint weiAmount,
        bytes memory transactionBytecode
    )
        view public
        returns (bool codeChecksOut)
    {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
    }

    /**
     * Log a vote for a proposal
     *
     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`
     *
     * @param proposalNumber number of proposal
     * @param supportsProposal either in favor or against it
     * @param justificationText optional justification text
     */
    function vote(
        uint proposalNumber,
        bool supportsProposal,
        string memory justificationText
    )
        onlyMembers public
        returns (uint voteID)
    {
        Proposal storage p = proposals[proposalNumber]; // Get the proposal
        require(!p.voted[msg.sender]);                  // If has already voted, cancel
        p.voted[msg.sender] = true;                     // Set this voter as having voted
        p.numberOfVotes++;                              // Increase the number of votes
        if (supportsProposal) {                         // If they support the proposal
            p.currentResult++;                          // Increase score
        } else {                                        // If they don't
            p.currentResult--;                          // Decrease the score
        }

        // Create a log of this event
        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);
        return p.numberOfVotes;
    }

    /**
     * Finish vote
     *
     * Count the votes proposal #`proposalNumber` and execute it if approved
     *
     * @param proposalNumber proposal number
     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it
     */
    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        Proposal storage p = proposals[proposalNumber];

        require(now &gt; p.minExecutionDate                                            // If it is past the voting deadline
            &amp;&amp; !p.executed                                                         // and it has not already been executed
            &amp;&amp; p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal
            &amp;&amp; p.numberOfVotes &gt;= minimumQuorum);                                  // and a minimum quorum has been reached...

        // ...then execute result

        if (p.currentResult &gt; majorityMargin) {
            // Proposal passed; execute the transaction

            p.executed = true; // Avoid recursive calling
            
            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);
            require(success);

            p.proposalPassed = true;
        } else {
            // Proposal failed
            p.proposalPassed = false;
        }

        // Fire Events
        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);
    }
}



</code></pre>
<h4>How to deploy</h4>
<p>Open the wallet (if you are only testing, go to the menu develop &gt; network &gt; testnet), go to the <strong>Contracts</strong> tab and then press <strong>deploy contract</strong>, and on the <strong>solidity code</strong> box, paste the code above. On the contract picker, choose <strong>Congress</strong> and you'll see the setup variables.</p>
<ul>
<li><strong>Minimum quorum for proposals</strong> is the minimum amount of votes a proposal needs to have before it can be executed.</li>
<li><strong>Minutes for debate</strong> is the minimum amount of time (in minutes) that needs to pass before it can be executed</li>
<li><strong>Margin of votes for majority</strong> A proposal passes if there are more than 50% of the votes plus the margin. Leave at 0 for simple majority, put it at the <em>number of members - 1</em> to require an absolute consensus.</li>
</ul>
<p><img src="/images/tutorial/dao-setup.png" alt="DAO Setup"></p>
<p>You can change these parameters later. As a start, you can choose 5 minutes for debate time and leave the remaining parameters at 0. A little lower on the page, you'll see an estimate of the cost for deploying your contract in ether. You can try lowering the price if you want to save, but that might mean having to wait longer for your contract to be created. Click <strong>Deploy</strong>, type your password and wait.</p>
<p>In a few seconds you'll be taken to the dashboard, scroll down and you'll be able to see your transaction being created. In under a minute you'll see the transaction successful and a new unique icon will have been created. Click the contract's name to see it (you can get to it at any time on the <em>Contracts</em> tab).</p>
<p><img src="/images/tutorial/dao-just-created.png" alt="DAO Just created"></p>
<h4>Sharing with others</h4>
<p>If you want to share your DAO with others, then they need both the contract address and the interface file, a small text string that works as an instruction manual of the contract. Click <strong>copy address</strong> to get the former and <strong>show interface</strong> to reveal the latter.</p>
<p>On the other computer, go into the <em>Contracts</em> tab and then click on <strong>watch contract</strong>. Add the correct address and interface and press <strong>OK</strong>.</p>
<p><img src="/images/tutorial/add-contract.png" alt="Add Contract"></p>
<h4>Interacting with the contract</h4>
<p>On the <strong>&quot;Read from contract&quot;</strong> you can see all the functions you can execute for free on the contract, as they are just reading information from the blockchain. Here you can see, for instance, the current &quot;owner&quot; of the contract (that should be the account that uploaded the contract).</p>
<p>On the <strong>&quot;Write to contract&quot;</strong> you have a list of all the functions that will attempt to do some computation that saves data to the blockchain, and therefore will cost ether. Select &quot;New Proposal&quot; and it will show all the options for that function.</p>
<p>Before interacting with the contract, you'll need to add new members so they can vote. On the <strong>&quot;Select function&quot;</strong> picker, choose <strong>&quot;Add Member&quot;</strong>. Add the address of the person you want to make a member(to remove a member, pick the function <strong>&quot;Remove Member&quot;</strong>). On <strong>&quot;execute from&quot;</strong> make sure that you have the same account that is set as the owner as this is an action only the main administrator can execute. Press <strong>execute</strong> and wait a few seconds for the next block to go through with your change.</p>
<p>There's no list of members, but you can check if anyone is a member by putting their address on the <strong>Members</strong> function on the <em>Read from contract</em> column.</p>
<p>Also, if you want the contract to have any money of its own, you need to deposit some ether (or other token) into it, otherwise you'll have a pretty toothless organization. Press <strong>Transfer Ether &amp; Tokens</strong> on the top right corner.</p>
<h4>Add a simple proposal: send ether</h4>
<p>Now let's add the first proposal to the contract. On the function picker, select <strong>New Proposal</strong>.</p>
<p>For &quot;beneficiary&quot; add the address of someone you want to send ether to, and put how much you want to send in the box marked &quot;Wei Amount.&quot; Wei is the smallest unit of ether, equal to 10^-18 ether, and must always be given as an integer. For example, if you want to send 1 ether, enter 1000000000000000000 (that's 18 zeroes). Finally, add some text describing the reason you want to do this. Leave &quot;Transaction bytecode&quot; blank for now. Click execute and type your password. After a few seconds the numProposals will increase to 1 and the first proposal, number 0, will appear on the left column. As you add more proposals, you can see any of them by simply putting the proposal number on the &quot;proposals&quot; field and you can read all about it.</p>
<p>Voting on a proposal is also very simple. Choose &quot;Vote&quot; on the function picker. Type the proposal Number in the first box and check the &quot;Yes&quot; box if you agree with it (or leave it blank to vote against it). Click &quot;<strong>execute</strong>&quot; to send your vote.</p>
<p><img src="/images/tutorial/dao-add-proposal.png" alt="Add new proposal"></p>
<p>When the voting time has passed, you can select <strong>&quot;executeProposal&quot;</strong>. If the proposal was simply sending ether, then you can also leave the &quot;<strong>transactionBytecode</strong>&quot; field blank. After pressing &quot;execute&quot; but before typing your password, pay attention to the screen that appears.</p>
<p><strong>If there is a warning on the &quot;estimated fee consumption&quot; field, then this means that for some reason the function called will not execute and will be abruptly terminated. It can mean many things, but in the context of this contract this warning will show up whenever you try to execute a contract before its deadline has passed, or if the user is trying to send a different bytecode data than the original proposal had. For security reasons if any of these things happens, the contract execution is abruptly terminated and the user that attempted the illegal transaction will lose all the ethers he sent to pay transaction fees.</strong></p>
<p>If the transaction was executed, then after a few seconds you should be able to see the result: <strong>executed</strong> will turn to true and the correct amount of ether should be subtracted from this contract's balance and into the recipient address.</p>
<h4>Add a complex proposal: own another token</h4>
<p>You can use this democracy to execute any transaction on ethereum, as long as you can figure out the bytecode that that transaction generates. Luckily for us, you can use the wallet to do precisely that!</p>
<p>In this example, we'll use a token to show that this contract can hold more than ether and can do transactions in any other ethereum-based asset. First, <a href="./token">create a token</a> that belongs to one of your normal accounts. On the contract page, click <strong>Transfer Ether &amp; Tokens</strong> to transfer some of them to your new congress contract (for simplicity, don't send more than half your coins to your DAO). After that, we are going to simulate the action you want to execute. So if you want to propose that the DAO send 500mg of a gold token to a person as a payment, then follow the steps that you'd do to execute that transaction from an account you own and press &quot;send&quot; but when the confirmation screens pops up, <strong>don't type your password</strong>.</p>
<p><img src="/images/tutorial/select-code.png" alt="Select the bytecode"></p>
<p>Instead, click &quot;SHOW RAW DATA&quot; link and copy the code displayed on the &quot;RAW DATA&quot; field and save it to a text file or notepad. Cancel the transaction. You'll also need the address of the contract you'll be calling for that operation, in this case the token contract. You can find it on the <em>Contracts</em> tab: save that somewhere too.</p>
<p>Now go back to the congress contract and create a new proposal with these parameters:</p>
<ul>
<li>As the <strong>beneficiary</strong>, put the address of your token (pay attention if it's the same icon)</li>
<li>Leave <strong>Ether amount</strong> blank</li>
<li>On the <strong>Job description</strong> just write a small description on what you want to accomplish</li>
<li>On the <strong>Transaction Bytecode</strong>, paste the bytecode you saved from the data field on the previous step</li>
</ul>
<p><img src="/images/tutorial/new-proposal-token.png" alt="New proposal"></p>
<p>In a few seconds you should be able to see the details on the proposal. You'll notice that the transaction bytecode won't be shown there and instead there's only a &quot;transaction hash&quot;. Unlike the other fields, Bytecode can be extremely lengthy and therefore expensive to store on the blockchain, so instead of archiving it, the person executing the call later will provide the bytecode.</p>
<p>But that, of course, creates a security hole: how can a proposal be voted without the actual code being there? And what prevents a user from executing a different code after the proposal has been voted on? That's where transaction hash comes in. Scroll a bit on the &quot;read from contract&quot; function list and you'll see a proposal checker function, where anyone can put all the function parameters and check if they match the one being voted on. This also guarantees that proposals don't get executed unless the hash of the bytecode matches exactly the one on the provided code.</p>
<p><img src="/images/tutorial/check-code.png" alt="It's an older code, but it checks out"></p>
<p>Anyone can actually check the proposal very easily by following the same steps to get the correct bytecode and then adding the proposal number and other parameters to the function called <strong>Check proposal code</strong> on the bottom of <strong>Read from contract</strong>.</p>
<p>The rest of the voting process remains the same: all members can vote and after the deadline, someone can execute the proposal. The only difference is that this time you'll have to provide the same bytecode you've submitted before. Pay attention to any warnings on the confirmation window: if it says it won't execute your code, check to see if the deadline has already passed, if there are enough votes and if your transaction bytecode checks out.</p>
<h4>Make it better</h4>
<p>Here are some drawbacks of this current DAO that we leave as an exercise to the reader:</p>
<ul>
<li>Can you make the member list public and indexed?</li>
<li>Can you allow members to change their votes (after votes are cast but before the votes are tallied up)?</li>
<li>Currently the vote message is only visible on logs, can you make a function that will display all votes?</li>
</ul>
<h3>The Shareholder Association</h3>
<p>In the previous section we created a contract that works like an invitation-only club, where members are invited or banned by the whim of the president. But this has a few drawbacks: what if someone wants to change his main address? What if some members have more weight than others? What if you actually want to trade or sell memberships or shares on an open market? What if you wanted your organization to have work as a constant decision machine by shareholders?</p>
<p>We are going to modify a bit our contract to connect it to a specific token, which will work as the holding shares of the contract. First we need to create this token: go to the <a href="./token">token tutorial</a> and create a simple token with <strong>initial supply</strong> of 100, <strong>decimals</strong> of 0 and a percentage sign (%) as a <strong>symbol</strong>. If you want to be able to trade in fractions of a percent, then increase the supply by 100x or 1000x and then add the corresponding amount of zeros as the <strong>decimals</strong>. Deploy this contract and save its address on a text file.</p>
<p>Now to the shareholder code:</p>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable external {
        emit receivedEther(msg.sender, msg.value);
    }
}

contract Token {
    mapping (address =&gt; uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}

/**
 * The shareholder association contract itself
 */
contract Association is owned, tokenRecipient {

    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    Proposal[] public proposals;
    uint public numProposals;
    Token public sharesTokenAddress;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter);
    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);
    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint minExecutionDate;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address =&gt; bool) voted;
    }

    struct Vote {
        bool inSupport;
        address voter;
    }

    // Modifier that allows only shareholders to vote and create new proposals
    modifier onlyShareholders {
        require(sharesTokenAddress.balanceOf(msg.sender) &gt; 0);
        _;
    }

    /**
     * Constructor
     *
     * First time setup
     */
    constructor(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable public {
        changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate);
    }

    /**
     * Change voting rules
     *
     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours
     * and all voters combined must own more than `minimumSharesToPassAVote` shares of token `sharesAddress` to be executed
     *
     * @param sharesAddress token address
     * @param minimumSharesToPassAVote proposal can vote only if the sum of shares held by all voters exceed this number
     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed
     */
    function changeVotingRules(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner public {
        sharesTokenAddress = Token(sharesAddress);
        if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1;
        minimumQuorum = minimumSharesToPassAVote;
        debatingPeriodInMinutes = minutesForDebate;
        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, address(sharesTokenAddress));
    }

    /**
     * Add Proposal
     *
     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     *
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send, in wei
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposal(
        address beneficiary,
        uint weiAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyShareholders public
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = weiAmount;
        p.description = jobDescription;
        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);
        numProposals = proposalID+1;

        return proposalID;
    }

    /**
     * Add proposal in Ether
     *
     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     * This is a convenience function to use if the amount to be given is in round number of ether units.
     *
     * @param beneficiary who to send the ether to
     * @param etherAmount amount of ether to send
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposalInEther(
        address beneficiary,
        uint etherAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyShareholders public
        returns (uint proposalID)
    {
        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);
    }

    /**
     * Check if a proposal code matches
     *
     * @param proposalNumber ID number of the proposal to query
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send
     * @param transactionBytecode bytecode of transaction
     */
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint weiAmount,
        bytes memory transactionBytecode
    )
        view public
        returns (bool codeChecksOut)
    {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
    }

    /**
     * Log a vote for a proposal
     *
     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`
     *
     * @param proposalNumber number of proposal
     * @param supportsProposal either in favor or against it
     */
    function vote(
        uint proposalNumber,
        bool supportsProposal
    )
        onlyShareholders public
        returns (uint voteID)
    {
        Proposal storage p = proposals[proposalNumber];
        require(p.voted[msg.sender] != true);

        voteID = p.votes.length++;
        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});
        p.voted[msg.sender] = true;
        p.numberOfVotes = voteID +1;
        emit Voted(proposalNumber,  supportsProposal, msg.sender);
        return voteID;
    }

    /**
     * Finish vote
     *
     * Count the votes proposal #`proposalNumber` and execute it if approved
     *
     * @param proposalNumber proposal number
     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it
     */
    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        Proposal storage p = proposals[proposalNumber];

        require(now &gt; p.minExecutionDate                                             // If it is past the voting deadline
            &amp;&amp; !p.executed                                                          // and it has not already been executed
            &amp;&amp; p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); // and the supplied code matches the proposal...


        // ...then tally the results
        uint quorum = 0;
        uint yea = 0;
        uint nay = 0;

        for (uint i = 0; i &lt;  p.votes.length; ++i) {
            Vote storage v = p.votes[i];
            uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
            quorum += voteWeight;
            if (v.inSupport) {
                yea += voteWeight;
            } else {
                nay += voteWeight;
            }
        }

        require(quorum &gt;= minimumQuorum); // Check if a minimum quorum has been reached

        if (yea &gt; nay ) {
            // Proposal passed; execute the transaction

            p.executed = true;
            
            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);
            require(success);

            p.proposalPassed = true;
        } else {
            // Proposal failed
            p.proposalPassed = false;
        }

        // Fire Events
        emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);
    }
}

</code></pre>
<h4>Deployment and usage</h4>
<p>The code is deployed almost exactly like the previous code, but you need to also put a <strong>shares token address</strong> which is the address of the token that will work as a share with voting rights.</p>
<p>Notice these lines of codes: first we describe the token contract to our new contract. Since it only uses the <strong>balanceOf</strong> function, we only need to add that single line.</p>
<pre><code>contract Token { mapping (address =&gt; uint256) public balanceOf; }
</code></pre>
<p>Then we define a variable of the <em>type</em> token, meaning that it will inherit all the functions we described earlier. Finally we point the token variable to an address on the blockchain, so it can use that and request live information. This is the simplest way to make one contract understand the other in ethereum.</p>
<pre><code>contract Association {
    token public sharesTokenAddress;
// ...
constructor(token sharesAddress, uint minimumSharesForVoting, uint minutesForDebate) {
        sharesTokenAddress = token(sharesAddress);
</code></pre>
<p>This association presents a challenge that the previous congress didn't have: since anyone with tokens can vote and the balances can change very quickly, the actual score of the proposal can't be counted when the shareholder votes, otherwise someone would be able to vote multiple times by simply sending his share to different addresses. So in this contract only the vote position is recorded and then the real score is tallied up on the <strong>execute proposal</strong> phase.</p>
<pre><code>uint quorum = 0;
uint yea = 0;
uint nay = 0;

for (uint i = 0; i &lt;  p.votes.length; ++i) {
    Vote v = p.votes[i];
    uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
    quorum += voteWeight;
    if (v.inSupport) {
        yea += voteWeight;
    } else {
        nay += voteWeight;
    }
}
</code></pre>
<p>Another way to count the weighted votes would be to create a single signed integer to keep score of the votes and check if it was positive or negative at the end, but you'd have to convert the <em>unsigned integer</em> voteWeight into a <em>signed integer</em> using <strong>int score = int(voteWeight);</strong></p>
<p>Using this DAO is exactly like before: members create new proposals, vote on them, wait until the deadline passes and then anyone can count the votes and execute it.</p>
<p><img src="/images/tutorial/association-dao.png" alt="Association example"></p>
<h4>But how can I limit the owner's power?</h4>
<p>On this contract the address set as <strong>owner</strong> has some special powers: they can add or ban members at will, change the margin needed for a win, alter the time required for debate and the quorum necessary for the vote to pass. But this can be solved by using yet another power the owner has: to change ownership.</p>
<p>The owner could change the ownership to no one by pointing the new owner as <em>0x00000...</em>. This would guarantee that the rules will never change, but it's an irreversible action. The owner can also change the ownership to the contract itself: just click on &quot;copy address&quot; and add it on the &quot;new owner&quot; field. This would make that all the powers of the owner could be executed by creating proposals.</p>
<p>If you want, you can also set one contract as the owner of the other: suppose you wanted a corporate structure where you wanted a President for life that had the power to appoint board members, which could then issue more shares and finally these shares voted on how to spend a budget. You could create an <strong>Association</strong> contract, that used a <strong><a href="./token">mintable token</a></strong> owned by a <strong>congress</strong> finally owned by a single account.</p>
<p>But what if you wanted different rules for voting? Maybe to change voting rules you'd need a 80% consensus, or maybe the members are different. In that case, you can create another identical DAO or use some other source code and plug that one as the owner of the first.</p>
<h3>Liquid democracy</h3>
<p>Voting on all expenses and actions of a contract takes time and requires users to be constantly active, informed and attentive. Another interesting approach is to elect an appointed account that will have control over a contract and then be able to take swift decisions over it.</p>
<p>We are going to implement a version of what's usually called <strong>Liquid Democracy</strong>, which is a more flexible delegative democracy. In this kind of democracy, any voter can be a potential delegate: instead of voting the candidate you want, you just say which voter you trust to handle this decision for you. Your voting weight is delegated to them and they can in turn delegate it to another voter they trust and so on. The end result should be that the most voted account is one that has trust connections to the largest amount of voters.</p>
<h4>The code</h4>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract token {
    mapping (address =&gt; uint256) public balanceOf;
}

contract LiquidDemocracy {
    token public votingToken;
    bool  underExecution;
    address public appointee;
    mapping (address =&gt; uint) public voterId;
    mapping (address =&gt; uint256) public voteWeight;

    uint public delegatedPercent;
    uint public lastWeightCalculation;
    uint public numberOfDelegationRounds;

    uint public numberOfVotes;
    DelegatedVote[] public delegatedVotes;
    string public forbiddenFunction;

    event NewAppointee(address newAppointee, bool changed);

    struct DelegatedVote {
        address nominee;
        address voter;
    }

    /**
     * Constructor
     */
    constructor(
        address votingWeightToken,
        string memory forbiddenFunctionCall,
        uint percentLossInEachRound
    ) public {
        votingToken = token(votingWeightToken);
        delegatedVotes.length++;
        delegatedVotes[0] = DelegatedVote({nominee: address(0), voter: address(0)});
        forbiddenFunction = forbiddenFunctionCall;
        delegatedPercent = 100 - percentLossInEachRound;
        if (delegatedPercent &gt; 100) delegatedPercent = 100;
    }

    /**
     * Vote for an address
     *
     * Send your vote weight to another address
     *
     * @param nominatedAddress the destination address receiving the sender's vote
     */
    function vote(address nominatedAddress) public returns (uint voteIndex) {
        if (voterId[msg.sender]== 0) {
            voterId[msg.sender] = delegatedVotes.length;
            numberOfVotes++;
            voteIndex = delegatedVotes.length++;
            numberOfVotes = voteIndex;
        }
        else {
            voteIndex = voterId[msg.sender];
        }

        delegatedVotes[voteIndex] = DelegatedVote({nominee: nominatedAddress, voter: msg.sender});

        return voteIndex;
    }

    /**
     * Perform Executive Action
     *
     * @param target the destination address to interact with
     * @param valueInWei the amount of ether to send along with the transaction
     * @param bytecode the data bytecode for the transaction
     */
    function execute(address target, uint valueInWei, bytes32 bytecode) public {
        require(msg.sender == appointee                             // If caller is the current appointee,
            &amp;&amp; !underExecution                                      // if the call is being executed,
            &amp;&amp; bytes4(bytecode) != bytes4(keccak256(abi.encodePacked(forbiddenFunction)))  // and it's not trying to do the forbidden function
            &amp;&amp; numberOfDelegationRounds &gt;= 4);                      // and delegation has been calculated enough

        underExecution = true;
        (bool success, ) = target.call.value(valueInWei)(abi.encode(bytecode)); // Then execute the command.
        require(success); 
        underExecution = false;
    }

    /**
     * Calculate Votes
     *
     * Go thruogh all the delegated vote logs and tally up each address's total rank
     */
    function calculateVotes()  public returns (address winner) {
        address currentWinner = appointee;
        uint currentMax = 0;
        uint weight = 0;
        DelegatedVote storage v = delegatedVotes[0];

        if (now &gt; lastWeightCalculation + 90 minutes) {
            numberOfDelegationRounds = 0;
            lastWeightCalculation = now;

            // Distribute the initial weight
            for (uint i=1; i&lt; delegatedVotes.length; i++) {
                voteWeight[delegatedVotes[i].nominee] = 0;
            }
            for (uint i=1; i&lt; delegatedVotes.length; i++) {
                voteWeight[delegatedVotes[i].voter] = votingToken.balanceOf(delegatedVotes[i].voter);
            }
        }
        else {
            numberOfDelegationRounds++;
            uint lossRatio = 100 * delegatedPercent ** numberOfDelegationRounds / 100 ** numberOfDelegationRounds;
            if (lossRatio &gt; 0) {
                for (uint i=1; i&lt; delegatedVotes.length; i++){
                    v = delegatedVotes[i];

                    if (v.nominee != v.voter &amp;&amp; voteWeight[v.voter] &gt; 0) {
                        weight = voteWeight[v.voter] * lossRatio / 100;
                        voteWeight[v.voter] -= weight;
                        voteWeight[v.nominee] += weight;
                    }

                    if (numberOfDelegationRounds&gt;3 &amp;&amp; voteWeight[v.nominee] &gt; currentMax) {
                        currentWinner = v.nominee;
                        currentMax = voteWeight[v.nominee];
                    }
                }
            }
        }

        if (numberOfDelegationRounds &gt; 3) {
            emit NewAppointee(currentWinner, appointee == currentWinner);
            appointee = currentWinner;
        }

        return currentWinner;
    }
}


</code></pre>
<h4>Deployment</h4>
<p>First, you need a token. If you have followed the <strong>Shareholder association</strong> tutorial above, you can use the same token as you had previously, otherwise just <a href="./token">deploy a new token</a> and distribute it among some accounts. Copy the token address.</p>
<p>Deploy the democracy contract, and put the token address on the <strong>Voting weight token</strong>, put <strong>75</strong> as the <strong>Percent loss in each round</strong> and <strong>transferOwnership(address)</strong> (without any spaces or extra characters!) as the <strong>forbidden function</strong>.</p>
<h4>Selecting a delegate</h4>
<p>Now deploy the Liquid democracy and go to its page. First have any of the shareholders <strong>vote</strong> on who they would trust to make decisions on behalf of this contract. You can vote on yourself if you want to be the final decision maker, or on the zero address, if you'd rather have no one representing you on that role.</p>
<p>After enough people have cast their votes, you can execute the function <strong>Calculate Votes</strong> so it will calculate everyone's voting weight. This function needs to be run multiple times, so the first run it will just set everyone's weight as their balance in the selected token, in the next round that voting weight will go to the person you voted appointed, in the next it will go to the person voted by the person you chose and so on. To prevent infinite loops of vote delegations, each time a vote is forwarded it loses a bit of power, set by at contract launch at <strong>percentLossInEachRound</strong>. So if the loss is set at 75%, it means that the person you vote gets 100% of your weight, but if they delegate the vote to someone else only 75% of their weight is forwarded. That person can delegate to someone else but they'll get only 56% of your voting weight and so on. If the ratio is anything lower than 100% there will be a finite moment where recalculating voting delegation won't change the result anymore, but if it's a 100% it means that voting weights will simply circulate around any potential loops.</p>
<p>If there has been more than one hour and a half since this round of calling <strong>Calculate votes</strong> has started, all weights will reset and will be recalculated based on the original token balance, so if you have recently received more tokens you should execute this function again.</p>
<h4>House of representatives</h4>
<p>What is all that vote delegation good for? For one, you can use it instead of the token weight on an <strong>Association</strong>. First of all, get the code for a <a href="#the-shareholder-association">shareholder association</a> but replace the first lines where it describes the token:</p>
<pre><code>contract Token {
    mapping (address =&gt; uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}
</code></pre>
<p>Into this:</p>
<pre><code>contract Token {
    mapping (address =&gt; uint256) public voteWeight;
    uint public numberOfDelegationRounds;

    function balanceOf(address member) public view returns (uint256 balance) {
        if (numberOfDelegationRounds &lt; 3)
            return 0;
        else
            return this.voteWeight(member);
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}
</code></pre>
<p>When you are writing your contract you can describe multiple other contracts used by your main contract. Some might be functions and variables that are already defined on the target contract, like <strong>voteWeight</strong> and <strong>numberOfDelegationRounds</strong>. But notice that <strong>balanceOf</strong> is a new function, that doesn't exist neither on the Liquid Democracy or the Association contract, we are defining it now, as a function that will return the <strong>voteWeight</strong> if at least three rounds of delegations have been calculated.</p>
<p>Use the <strong>Liquid democracy</strong> as the <strong>Token Address</strong> instead of the original token and proceed to deploy the shareholder association as usual. Just like before, users can create new proposals on what to do or cast votes on these issues, but now, <strong>instead of using the token balance as the voting power we are using a delegative process</strong>. So if you are a token holder, instead of having to keep yourself constantly informed by all the issues, you can just select someone you trust and appoint them, and then they can choose someone they trust: the result is that your representative, instead of being limited to a given arbitrary <strong>geographical proximity</strong>, will be someone in your <strong>social proximity</strong>.</p>
<p>Also it means that you can switch your vote at any moment: if your representative has voted against your interests in some issue you can, before the proposal votes are tallied up, switch your appointee, or just choose to represent yourself on the issue and cast the vote yourself.</p>
<h4>The Executive Branch</h4>
<p>Delegative democracies are a great way to choose representatives, but voting on individual proposals might be too slow for some important or simpler decisions: that's why most democratic governments have an executive branch, where an appointed person has the right to represent the state.</p>
<p>After four rounds of delegations, the address with more weight will be set as the <strong>Appointee</strong>. If there are many delegated votes, then a few more rounds of <strong>Calculate Votes</strong> might be necessary to settle in the final appointed address.</p>
<p>The Appointee is the only address that can call the <strong>Execute</strong> function, which will be able to execute (almost) any function representing the democracy as a whole. If there is any ether or token stored in the Liquid democracy contract, the Appointee will be allowed to move it anywhere.</p>
<p>If you have followed our example and created a <strong>Shareholder association</strong> using this liquid democracy as a token, then you should be able to use the executive branch in an interesting manner: go to the main Association address and execute a <strong>Transfer Ownership</strong> function to the liquid democracy.</p>
<p>Once that transfer is complete, switch the function to <strong>Change Voting Rules</strong>. This allows you to change some essential voting rules, like the minimum quorum needed for a vote to pass or the time a new proposal needs to stay on the floor. Try changing these settings and click <strong>execute</strong>: when the confirmation window pops up it will tell you that the transaction <em>Can't be executed</em>. This happens, of course, because only the address set as <strong>Owner</strong> can change these settings and the contract will reject this transaction attempt. So <strong>instead of typing your password</strong> copy the code on the <strong>data</strong> field and save it to a text file. Click cancel, scroll to the top and click <strong>copy address</strong> and also save that to a text file.</p>
<p>Now go to the Liquid democracy page and choose <strong>execute</strong>. On <strong>target</strong> put the address of the association contract, leave <strong>ether amount</strong> at 0 and paste the code you copied previously into the <strong>bytecode data</strong> field. Make sure you are executing it from the account set as the <strong>appointee</strong> and click <strong>execute</strong>.</p>
<p>Once the transaction has been picked up, the Liquid democracy will pass the order to the association and the new voting rules might apply. The appointee has the absolute power to do anything that the <strong>Liquid democracy</strong> contract can execute. You can use the same technique to create a <a href="./token">Mintable Token</a> owned by the delegative democracy, and then allow the appointee to mint tokens or freeze accounts.</p>
<p>To prevent abuses of powers, you can set one <strong>Forbidden function</strong> that the Appointee cannot ever do. If you followed our example the forbidden function is the <strong>transferOwnership(address)</strong>, to prevent the appointee from transferring the ownership of the association to themselves (in politics, when a president uses his executive power to transfer to themselves something that used to belongs to the presidency, it's a coup or embezzling).</p>
<h3>Time-Locked Multisig</h3>
<p>Sometimes time can also be used as a great security mechanism. The following code is based on the congress DAO but with a different twist. Instead of every action requiring the approval of an X number of members, instead any transactions can be initiated by a single member, but they all will require a minimum amount of delay before they can be executed, which varies according to the support that transaction has. The more approvals a proposal has, the sooner it can be executed. A member can vote against a transaction, which will mean that it will cancel one of the other approved signatures.</p>
<p>This means that if you don't have urgency, one or two signatures might be all you need to execute any transaction. But if a single key is compromised, other keys can delay that transaction for months or year or even stop it from being executed.</p>
<h4>How it works</h4>
<p>A transaction that has been approved by all keys can be executed after ten minutes (this amount is configurable), and the amount of time it requires doubles every time for every 5% of members who don't vote (and quadruples if they actively vote against). If it's a simple ether transaction, the transaction is executed as soon as a vote of support puts it under the required time, but a more complex transaction will require it to be manually executed with the correct bytecode. These are the default values, but this can be set differently when creating the contract:</p>
<p><strong>Number of members approving transaction: Approximate time delay</strong></p>
<ul>
<li>100% approval:                                10 minutes (minimum default)</li>
<li>90% approval:                                 40 minutes</li>
<li>80%:                                          2hr 40min</li>
<li>50%:                                          about a week</li>
<li>40%:                                          1 month</li>
<li>30%:                                          4 months</li>
<li>20%:                                          Over a year</li>
<li>10% or less:                                  5 years or never</li>
</ul>
<p>Once the minimum amount of time has passed, anyone can execute the transaction <a href="dao#add-a-simple-proposal-send-ether">(See &quot;Congress&quot; for a more complete walktrough)</a>. This is intentional, as it allows someone to <a href="crowdsale#scheduling-a-call">schedule a transaction</a> or hire someone else to execute it.</p>
<h4>The code</h4>
<pre><code>pragma solidity &gt;=0.4.22 &lt;0.6.0;

contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable external {
        emit receivedEther(msg.sender, msg.value);
    }
}

interface Token {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract TimeLockMultisig is owned, tokenRecipient {

    Proposal[] public proposals;
    uint public numProposals;
    mapping (address =&gt; uint) public memberId;
    Member[] public members;
    uint minimumTime = 10;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter, string justification);
    event ProposalExecuted(uint proposalID, int result, uint deadline);
    event MembershipChanged(address member, bool isMember);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        bool executed;
        int currentResult;
        bytes32 proposalHash;
        uint creationDate;
        Vote[] votes;
        mapping (address =&gt; bool) voted;
    }

    struct Member {
        address member;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    // Modifier that allows only shareholders to vote and create new proposals
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }

    /**
     * Constructor
     *
     * First time setup
     */
    constructor(
        address founder, 
        address[] memory initialMembers, 
        uint minimumAmountOfMinutes
    ) payable public {
        if (founder != address(0)) owner = founder;
        if (minimumAmountOfMinutes !=0) minimumTime = minimumAmountOfMinutes;
        // It’s necessary to add an empty first member
        addMember(address(0), '');
        // and let's add the founder, to save a step later
        addMember(owner, 'founder');
        changeMembers(initialMembers, true);
    }

    /**
     * Add member
     *
     * @param targetMember address to add as a member
     * @param memberName label to give this member address
     */
    function addMember(address targetMember, string memory memberName) onlyOwner public
    {
        uint id;
        if (memberId[targetMember] == 0) {
            memberId[targetMember] = members.length;
            id = members.length++;
        } else {
            id = memberId[targetMember];
        }

        members[id] = Member({member: targetMember, memberSince: now, name: memberName});
        emit MembershipChanged(targetMember, true);
    }

    /**
     * Remove member
     *
     * @param targetMember the member to remove
     */
    function removeMember(address targetMember) onlyOwner public {
        require(memberId[targetMember] != 0);

        for (uint i = memberId[targetMember]; i&lt;members.length-1; i++){
            members[i] = members[i+1];
            memberId[members[i].member] = i;
        }
        memberId[targetMember] = 0;
        delete members[members.length-1];
        members.length--;
    }

    /**
     * Edit existing members
     *
     * @param newMembers array of addresses to update
     * @param canVote new voting value that all the values should be set to
     */
    function changeMembers(address[] memory newMembers, bool canVote) public {
        for (uint i = 0; i &lt; newMembers.length; i++) {
            if (canVote)
                addMember(newMembers[i], '');
            else
                removeMember(newMembers[i]);
        }
    }

    /**
     * Add Proposal
     *
     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     *
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send, in wei
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposal(
        address beneficiary,
        uint weiAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyMembers public
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = weiAmount;
        p.description = jobDescription;
        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
        p.executed = false;
        p.creationDate = now;
        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);
        numProposals = proposalID+1;
        vote(proposalID, true, '');

        return proposalID;
    }

    /**
     * Add proposal in Ether
     *
     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
     * This is a convenience function to use if the amount to be given is in round number of ether units.
     *
     * @param beneficiary who to send the ether to
     * @param etherAmount amount of ether to send
     * @param jobDescription Description of job
     * @param transactionBytecode bytecode of transaction
     */
    function newProposalInEther(
        address beneficiary,
        uint etherAmount,
        string memory jobDescription,
        bytes memory transactionBytecode
    )
        onlyMembers public
        returns (uint proposalID)
    {
        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);
    }

    /**
     * Check if a proposal code matches
     *
     * @param proposalNumber ID number of the proposal to query
     * @param beneficiary who to send the ether to
     * @param weiAmount amount of ether to send
     * @param transactionBytecode bytecode of transaction
     */
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint weiAmount,
        bytes memory transactionBytecode
    )
        view public
        returns (bool codeChecksOut)
    {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
    }

    /**
     * Log a vote for a proposal
     *
     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`
     *
     * @param proposalNumber number of proposal
     * @param supportsProposal either in favor or against it
     * @param justificationText optional justification text
     */
    function vote(
        uint proposalNumber,
        bool supportsProposal,
        string memory justificationText
    )
        onlyMembers public
    {
        Proposal storage p = proposals[proposalNumber]; // Get the proposal
        require(p.voted[msg.sender] != true);           // If has already voted, cancel
        p.voted[msg.sender] = true;                     // Set this voter as having voted
        if (supportsProposal) {                         // If they support the proposal
            p.currentResult++;                          // Increase score
        } else {                                        // If they don't
            p.currentResult--;                          // Decrease the score
        }

        // Create a log of this event
        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);

        // If you can execute it now, do it
        if ( now &gt; proposalDeadline(proposalNumber)
            &amp;&amp; p.currentResult &gt; 0
            &amp;&amp; p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, ''))
            &amp;&amp; supportsProposal) {
            executeProposal(proposalNumber, '');
        }
    }

    function proposalDeadline(uint proposalNumber) public view returns(uint deadline) {
        Proposal storage p = proposals[proposalNumber];
        uint factor = calculateFactor(uint(p.currentResult), (members.length - 1));
        return p.creationDate + uint(factor * minimumTime *  1 minutes);
    }

    function calculateFactor(uint a, uint b) public pure returns (uint factor) {
        return 2**(20 - (20 * a)/b);
    }

    /**
     * Finish vote
     *
     * Count the votes proposal #`proposalNumber` and execute it if approved
     *
     * @param proposalNumber proposal number
     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it
     */
    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        Proposal storage p = proposals[proposalNumber];

        require(now &gt;= proposalDeadline(proposalNumber)                                         // If it is past the voting deadline
            &amp;&amp; p.currentResult &gt; 0                                                              // and a minimum quorum has been reached
            &amp;&amp; !p.executed                                                                      // and it is not currently being executed
            &amp;&amp; checkProposalCode(proposalNumber, p.recipient, p.amount, transactionBytecode));  // and the supplied code matches the proposal...


        p.executed = true;
        (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);
        require(success);

        // Fire Events
        emit ProposalExecuted(proposalNumber, p.currentResult, proposalDeadline(proposalNumber));
    }
}

</code></pre>
<h4>Deployment and usage</h4>
<p>Deploy that code as you have done before on these tutorials. On the deployment parameters, leaving the minimum time blank will default to 30 minutes, if you want faster lock times, then put 1 minute. After uploading, execute the functions &quot;Add Members&quot; to add new members of your group, they can be either other people you know or accounts on different computers or stored offline.</p>
<p>The account set as &quot;owner&quot; is very powerful as it can add or remove members at will. Therefore, after you added the main members, we recommend that you set the &quot;owner&quot; to another account, by executing the function <strong>Transfer Membership</strong>. Set that to the multisig itself if you want to have all additions or removals of members to be voted, just like any other transaction. Another alternative is to set that to another trusted multisig wallet, or maybe to <em>0x000</em> if you want the number of members to be fixed forever. Remember, the funds on this contract are only as safe as the &quot;owner&quot; account.</p>
<p>As with any of the above DAO's, this contract can hold ether, any ethereum based tokens and execute any contract. To do that, check how to <a href="dao#add-a-complex-proposal-own-another-token">execute complex proposals</a> on the congress DAO.</p>
<h4>Caveats and improvements</h4>
<p>For simplicity's sake, a vote against a proposal simply counts as one less vote of support. If you want, you can play around with the idea that negative votes have more weight, but this means that a minority of members could have an effective veto power on any proposed transaction!</p>
<p>How else could you improve this contract?</p>
<h3>Let's go exploring!</h3>
<p>You have reached the end of this tutorial, but it's just the beginning of a great adventure. Look back and see how much you accomplished: you created a living, talking robot, your own cryptocurrency, raised funds through a trustless crowdfunding and used it to kickstart your own personal democratic organization.</p>
<h4>What could happen next?</h4>
<ul>
<li>
<p>The tokens you still control could be sold on a decentralized exchange or traded for goods and services to fund further development of the first contract and grow the organization.</p>
</li>
<li>
<p>Your DAO could own its own name on the name registrar, and then change where it's redirecting in order to update itself if the token holders approved.</p>
</li>
<li>
<p>The organization could hold not only ethers, but any other kind of coin created on ethereum, including assets whose values are tied to the bitcoin or dollar.</p>
</li>
<li>
<p>The DAO could be programmed to allow a proposal with multiple transactions, some scheduled to the future.
It could also own shares of other DAOs, meaning it could vote on larger organization or be a part of a federation of DAOs.</p>
</li>
<li>
<p>The Token Contract could be reprogrammed to hold ether or to hold other tokens and distribute it to the token holders. This would link the value of the token to the value of other assets, so paying dividends could be accomplished by simply moving funds to the token address.</p>
</li>
</ul>
<p>This all means that this tiny society you created could grow, get funding from third parties, pay recurrent salaries, own any kind of crypto-assets and even use crowdsales to fund its activities. All with full transparency, complete accountability and complete immunity from any human interference. While the network lives the contracts will execute exactly the code they were created to execute, without any exception, forever.</p>
<p>So what will your contract be? Will it be a country, a company, a non-profit group? What will your code do?</p>
<p>That's up to you.</p>
<a class="button small" href="https://github.com/ethereum/ethereum-org/edit/master/views/content/dao.md">Improve this page</a></div></div></div></div><div class="main-tutorial ethereum-projects even"><div class="container"><div class="row"><div class="col-md-12"><h2>What's next?</h2><div class="row"><div class="col-md-6"><h3>Build a new kind of decentralized application</h3><p>Now it's your turn: start building what you dream of creating in Ethereum! Could your business be enhanced by operating on a cryptographically secure, decentralized, tamper-proof network?</p><p>Check out the <a href="https://www.stateofthedapps.com" target="_blank">many great projects</a>* already being built on Ethereum. And since you'll be among the first developers in the world that are able to program decentralized applications, some of them might need your help. </p><p class="small"> <em>*The above list is maintained by an independent party and the Foundation does not endorse its content or any particular project</em></p></div><div class="col-md-6 future-figure"><figure class="moon scrollme"><div class="moon-stars animateme" data-when="span" data-from="0" data-to="1" data-translatey="100" data-rotatez="360" data-easing="linear"></div><div class="moon-moon animateme" data-when="span" data-from="0" data-to="1" data-translatey="100" data-rotatez="720" data-easing="linear"></div><div class="moon-rocket animateme" data-when="span" data-from="0" data-to="1" data-translatey="-200" data-easing="linear"></div></figure></div></div></div></div></div></div><script> ((window.gitter = {}).chat = {}).options = {
   room: 'ethereum/tutorials'
 };</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><footer class="scrollme"><div class="footer"><div class="container"><div class="row row-footer-news"><div class="col-md-12 news"><h3>News</h3><div class="iframe-wrapper"><a class="twitter-timeline" href="https://twitter.com/ethereum" data-widget-id="694952013856112640" data-chrome="nofooter noborders transparent noheader" width="100%" height="370px">Tweets by @ethereum</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div></div></div><div class="row row-footer-primary"><div class="col-md-4 community"><h3>Community</h3><div class="row"><div class="col-sm-5"><ul><li><a href="https://blog.ethereum.org" target="_blank"><i class="fa fa-rss"></i> Blog</a></li><li><a href="https://github.com/ethereum" target="_blank"><i class="fa fa-github"></i> GitHub</a></li><li><a href="https://www.youtube.com/user/ethereumproject" target="_blank"><i class="fa fa-youtube"></i> YouTube</a></li><li><a href="https://www.reddit.com/r/ethereum" target="_blank"><i class="fa fa-reddit"></i> Reddit</a></li><li><a href="https://gitter.im/orgs/ethereum/rooms" target="_blank"><i class="fa fa-comments-o"></i> Gitter</a></li></ul></div><div class="col-sm-7"><ul><li><a href="https://twitter.com/ethereum" target="_blank"><i class="fa fa-twitter"></i> Twitter</a></li><li><a href="https://ethereum.stackexchange.com" target="_blank"><i class="fa fa-stack-exchange"></i> Stack Exchange</a></li><li><a href="https://www.facebook.com/ethereumproject" target="_blank"><i class="fa fa-facebook"></i> Facebook                </a></li><li><a href="https://ethereum.meetup.com" target="_blank"><i class="fa fa-meetup"></i> Meetups</a></li></ul></div></div></div><div class="col-md-4 about-us"><h3>Ethereum Foundation</h3><p>Ethereum is developed by a worldwide team of passionate developers for the <a href="./foundation">Ethereum Foundation</a>, a Swiss nonprofit organization. </p><p> <a class="donate-button" href="./donate">Donate to support development </a><div class="caption">(and you can get a unicorn!)</div></p></div><div class="col-md-4 developer-resources"><h3>Developer Resources</h3><ul><li>What is Ether? <a href="./ether">Read our FAQ</a></li><li>Browse our source code on <a href="https://github.com/ethereum/" target="_blank">GitHub</a></li><li>Read the <a href="http://www.ethdocs.org/" target="_blank">documentation</a>
or <a href="https://github.com/ethereum/wiki/wiki" target="_blank">wiki</a></li><li>Learn <a href="https://solidity.readthedocs.org/" target="_blank">Solidity</a></li><li>See the latest <a href="https://ethstats.net" target="_blank">data and network stats</a></li><li>Download our <a href="./assets">logo assets </a></li><li>Want to write about Ethereum? <a href="mailto:press@ethereum.org">Press inquiries</a></li></ul></div></div><div class="row row-footer-copyright"><div class="col-md-12"><p class="copyright">Copyright &copy; 2018 Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland. All Rights Reserved.</p><p class="footer-links"> <a href="./privacy-policy">Privacy Policy </a>&nbsp; &nbsp; <a href="./cookie-policy">Cookie Policy</a>&nbsp; &nbsp; <a href="./terms-of-use">Terms of Use</a></p></div></div><div class="row row-footer-canary"><div class="col-md-12"><div class="canary"><p>The Ethereum Foundation (Stiftung Ethereum) has never been contacted by any agency anywhere in the world in a way which requires that contact not to be disclosed.</p><p>Stiftung Ethereum will publicly disclose any sort of inquiry from government agencies that falls outside the scope of regular business operations.</p></div></div></div></div></div></footer><script src="/js/app.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script>$(document).ready(function(){
    $("#toc").tableOfContents(
      $(".main-tutorial"),      // Scoped to div#wrapper
      {
        startLevel: 2,    // H2 and up
        depth:      3    // H2 through H4,
      }
    );
  });</script><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)
   },i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
   ga('create', 'UA-52040685-2', 'auto');
   ga('send', 'pageview');</script></body></html>